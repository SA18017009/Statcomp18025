<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="StatComp18025" />

<meta name="date" content="2019-01-11" />

<title>The code and answer of homework</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">The code and answer of homework</h1>
<h4 class="author"><em>StatComp18025</em></h4>
<h4 class="date"><em>2019-01-11</em></h4>



<div id="overview" class="section level2">
<h2>overview</h2>
</div>
<div id="question" class="section level2">
<h2>Question</h2>
<p>Write a .Rmd file to implement at least three examples of different types in the above books (texts, numerical results, tables, and figures).</p>
</div>
<div id="answer" class="section level2">
<h2>Answer</h2>
<p>The first example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">10</span>)
y &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">10</span>)
<span class="kw">plot</span>(x,y)</code></pre></div>
<p>The second example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(<span class="st">&quot;InsectSprays&quot;</span>)
aov.spray &lt;-<span class="st"> </span><span class="kw">aov</span>(<span class="kw">sqrt</span>(count) <span class="op">~</span><span class="st"> </span>spray,<span class="dt">data=</span>InsectSprays)
<span class="kw">summary</span>(aov.spray)</code></pre></div>
<p>The third example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m1 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">2</span>)
m2 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>)
<span class="kw">rbind</span>(m1,m2)
<span class="kw">cbind</span>(m1,m2)</code></pre></div>
</div>
<div id="question1" class="section level2">
<h2>Question1</h2>
<p>A discrete random variable X has probability mass function</p>
<pre><code> x     0    1  2   3    4
 p(x) 0.1 0.2 0.2 0.2 0.3</code></pre>
<p>Use the inverse transform method to generate a random sample of size 1000 from the distribution of X. Construct a relative frequency table and compare the empirical with the theoretical probabilities. Repeat using the R sample function.</p>
</div>
<div id="answer1" class="section level2">
<h2>Answer1</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Make a theoretical probability vector so that I can do the comparison below</span>
x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)
p &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.1</span>,<span class="fl">0.2</span>,<span class="fl">0.2</span>,<span class="fl">0.2</span>,<span class="fl">0.3</span>)

<span class="co">#A probability vector accumulated by the above probabilities is obtained.That is,cp=c(0.1,0.3,0.5,0.7,1)</span>
cp &lt;-<span class="st"> </span><span class="kw">cumsum</span>(p)
m &lt;-<span class="st"> </span><span class="fl">1e4</span>
r &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)

<span class="co">#Generate 10,000 random numbers  uniformly distributed over 0 to 1, and get the subscript in the vector of cp(cp=c(0.1,0.3,0.5,0.7,1)), according to this subscript get the corresponding value in the X vector</span>
r &lt;-<span class="st"> </span>x[<span class="kw">findInterval</span>(<span class="kw">runif</span>(m),cp)<span class="op">+</span><span class="dv">1</span>]

<span class="co">#Use table function to get frequency and then get empirical probability</span>
ct &lt;-<span class="st"> </span><span class="kw">table</span>(r)<span class="op">/</span>m

<span class="co">#The Sample function is used to extract 10000 samples from the population 0,1,2,3,4 with probability 0.1,0.2,0.2,0.2,0.3 respectively.</span>
x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>),m,p,<span class="dt">replace =</span> <span class="ot">TRUE</span>)

<span class="co">#Use table function again to get frequency and  empirical probability that generated by sample function</span>
y &lt;-<span class="st"> </span><span class="kw">table</span>(x)<span class="op">/</span>m

<span class="co">#The rbind function merges the three rows</span>
<span class="kw">rbind</span>(<span class="dt">prob=</span>p,<span class="dt">prob1=</span>ct,<span class="dt">prob2=</span>y)</code></pre></div>
</div>
<div id="question2" class="section level2">
<h2>Question2</h2>
<p>Write a function to generate a random sample of size n from the Beta(a,b) distribution by the acceptance-rejection method. Generate a random sample of size 1000 from the Beta(3,2) distribution. Graph the histogram of the sample with the theoretical Beta(3,2) density superimposed.</p>
</div>
<div id="answer2" class="section level2">
<h2>Answer2</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#Write a function that generates and return a random sample of size n from the Beta(a,b)distribution by the acceptance-rejection method </span>
beta &lt;-<span class="st"> </span><span class="cf">function</span>(n,a,b){
j&lt;-k&lt;-<span class="dv">0</span>
y &lt;-<span class="st"> </span><span class="kw">numeric</span>(n)
<span class="cf">while</span> (k <span class="op">&lt;</span><span class="st"> </span>n) {
  u &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
  j &lt;-<span class="st"> </span>j <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>) 
  <span class="cf">if</span> (x<span class="op">^</span>(a<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="st"> </span>(<span class="dv">1</span><span class="op">-</span>x)<span class="op">^</span>(b<span class="op">-</span><span class="dv">1</span>) <span class="op">&gt;</span><span class="st"> </span>u) {
    k &lt;-<span class="st"> </span>k <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    y[k] &lt;-<span class="st"> </span>x
  }
}
<span class="kw">return</span> (y)
}

<span class="co">#Use the above function to generate a total of 1000 points from Beta distribution with parameter 3 and 2, and draw the corresponding histogram</span>
r&lt;-<span class="kw">beta</span>(<span class="dv">1000</span>,<span class="dv">3</span>,<span class="dv">2</span>)
<span class="kw">hist</span>(r,<span class="dt">prob=</span><span class="ot">TRUE</span>,<span class="dt">main=</span><span class="st">&quot;the histogram of Beta(3,2) and its density&quot;</span>,<span class="dt">col=</span><span class="st">&quot;red&quot;</span>)

<span class="co">#Generate 1000 points from theoretical Beta (3,2) and plot them on the same diagram</span>
t&lt;-<span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.001</span>)
s&lt;-<span class="kw">dbeta</span>(t,<span class="dv">3</span>,<span class="dv">2</span>)
<span class="kw">lines</span>(t,s,<span class="dt">col=</span><span class="st">&quot;blue&quot;</span>,<span class="dt">lwd=</span><span class="dv">3</span>)</code></pre></div>
</div>
<div id="question3" class="section level2">
<h2>Question3</h2>
<p>Simulate a continuous Exponential-Gamma mixture. Suppose that the rate parameter ?? has Gamma(r, ??) distribution and Y has Exp(??) distribution.That is, <span class="math inline">\((Y|??=??)\)</span>~ <span class="math inline">\(f_Y(y|??) = ??e^{-??y}\)</span> . Generate 1000 random observations from this mixture with <span class="math inline">\(r= 4\)</span> and <span class="math inline">\(??=2\)</span>.</p>
</div>
<div id="answer3" class="section level2">
<h2>Answer3</h2>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="fl">1e3</span>; r &lt;-<span class="st"> </span><span class="dv">4</span>; beta &lt;-<span class="st"> </span><span class="dv">2</span>
lambda &lt;-<span class="st"> </span><span class="kw">rgamma</span>(n, r, beta)
y &lt;-<span class="st"> </span><span class="kw">rexp</span>(n, lambda)
y
<span class="kw">plot</span>(<span class="kw">density</span>(y), <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dt">main =</span> <span class="st">&quot;Exponential-Gamma distribution&quot;</span>, <span class="dt">xlab =</span> <span class="st">&quot;Y&quot;</span>, <span class="dt">ylab =</span> <span class="st">&quot;density&quot;</span>, <span class="dt">col =</span> <span class="st">&quot;darkblue&quot;</span>, <span class="dt">lwd=</span><span class="dv">2</span>)</code></pre></div>
</div>
<div id="question-1" class="section level2">
<h2>Question</h2>
<ul>
<li><p>5.4 Write a function to compute a Monte Carlo estimate of the Beta(3, 3) cdf,and use the function to estimate F(x) for x = 0.1,0.2,…,0.9. Compare the estimates with the values returned by the pbeta function in R.</p></li>
<li><p>5.9 The Rayleigh density [156, (18.76)] is <span class="math display">\[{f(x)}=\frac{x}{\sigma^2}e^{-x^2/{(2\sigma^2)}},x≥0,\sigma&gt;0\]</span> Implement a function to generate samples from a Rayleigh(σ) distribution,using antithetic variables. What is the percent reduction in variance of <span class="math inline">\(\frac{x+x'}{2}\)</span> compared with <span class="math inline">\(\frac{x_1+x_2}{2}\)</span> for independent <span class="math inline">\({x_1+x_2}\)</span></p></li>
<li><p>5.13 Find two importance functions <span class="math inline">\(f_1\)</span> and <span class="math inline">\(f_2\)</span> that are supported on (1,∞) and are ‘close’ to <span class="math display">\[g(x)=\frac{x^2}{\sqrt{2\pi}}e^{-x^2/2}\]</span> Which of your two importance functions should produce the smaller variance in estimating <span class="math display">\[\int_0^∞ \frac{x^2}{\sqrt{2\pi}}e^{-x^2/2}{dx}\]</span></p></li>
</ul>
<p>by importance sampling? Explain.</p>
<ul>
<li>5.14 Obtain a Monte Carlo estimate of <span class="math display">\[\int_0^∞ \frac{x^2}{\sqrt{2\pi}}e^{-x^2/2}{dx}\]</span> by importance sampling</li>
</ul>
</div>
<div id="answer-1" class="section level2">
<h2>Answer</h2>
<p>5.4 The pdf of <span class="math inline">\(Beta(3,3)\)</span> is <span class="math display">\[30x^2(1-x)^2\]</span> So,we can use the pdf and the Monte Carlo integration to estimate the <span class="math inline">\(F(x)\)</span>.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#create a function(mtbeta) which uses the Monte Carlo integration and to estimate F(x)</span>
mtbeta &lt;-<span class="st"> </span><span class="cf">function</span>(x){
  m &lt;-<span class="st"> </span><span class="fl">1e5</span>
  t &lt;-<span class="st"> </span><span class="kw">runif</span>(m,<span class="dv">0</span>,x)
  <span class="kw">mean</span>(<span class="dv">30</span><span class="op">*</span>t<span class="op">*</span>t<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>t)<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>t))<span class="op">*</span>x
}
mbeta &lt;-<span class="st"> </span><span class="kw">Vectorize</span>(mtbeta)

<span class="co"># estimate F(x) for x = 0.1,0.2,...,0.9.</span>
s &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="fl">0.1</span>,<span class="fl">0.9</span>,<span class="fl">0.1</span>)
<span class="kw">print</span>(<span class="kw">round</span>(<span class="kw">rbind</span>(<span class="dt">x=</span>s,<span class="dt">p=</span><span class="kw">pbeta</span>(s,<span class="dv">3</span>,<span class="dv">3</span>),<span class="dt">phat=</span><span class="kw">mbeta</span>(s),<span class="dt">se=</span><span class="kw">mbeta</span>(s)<span class="op">-</span><span class="kw">pbeta</span>(s,<span class="dv">3</span>,<span class="dv">3</span>)),<span class="dv">5</span>))</code></pre></div>
<p>5.9<br />
Set <span class="math inline">\(\sigma\)</span> is 1,so the Rayleigh density is <span class="math display">\[{f(x)}=xe^{-x^2/{2}},x≥0\]</span> We create a function named mtrayl to generate samples from a Rayleigh(σ) distribution and the function allows us to use antithetic variables or not by setting the parameter that’s antithetic as TRUE. Now,we have the function(mtrayl) and create a vector of x from 0 to 2.5 by 0.5 and use mtrayl to generate samples in two different methods.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#create a function called mtrayl</span>
mtrayl &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">R =</span> <span class="dv">10000</span>, <span class="dt">antithetic =</span> <span class="ot">TRUE</span>) {
u &lt;-<span class="st"> </span><span class="kw">runif</span>(R<span class="op">/</span><span class="dv">2</span>)
<span class="cf">if</span> (<span class="op">!</span>antithetic) v &lt;-<span class="st"> </span><span class="kw">runif</span>(R<span class="op">/</span><span class="dv">2</span>) <span class="cf">else</span>
v &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span>u
u &lt;-<span class="st"> </span><span class="kw">c</span>(u, v)
cdf &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(x))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x)) {
g &lt;-<span class="st"> </span>x[i]<span class="op">^</span><span class="dv">2</span><span class="op">*</span>u <span class="op">*</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>(u <span class="op">*</span><span class="st"> </span>x[i])<span class="op">^</span><span class="dv">2</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>)
cdf[i] &lt;-<span class="st"> </span><span class="kw">mean</span>(g)
}
cdf
}
x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>, <span class="fl">2.5</span>,<span class="fl">0.5</span>)

<span class="co">#set the parameter anti=FALSE,we use two independent variable to get the samples</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
mtr1 &lt;-<span class="st"> </span><span class="kw">mtrayl</span>(x, <span class="dt">anti =</span> <span class="ot">FALSE</span>)

<span class="co">#set the parameter anti=TRUE,we use antithetic variable to get the samples</span>
<span class="kw">set.seed</span>(<span class="dv">123</span>)
mtr2 &lt;-<span class="st"> </span><span class="kw">mtrayl</span>(x,<span class="dt">anti =</span> <span class="ot">TRUE</span>)
<span class="kw">print</span>(<span class="kw">round</span>(<span class="kw">rbind</span>(x, mtr1, mtr2), <span class="dv">5</span>))

<span class="co">#Given x=1 by a simulation under both methods, the simple Monte Carlo integration approach and the antithetic variable approach</span>
m &lt;-<span class="st"> </span><span class="dv">1000</span>
mtr3 &lt;-<span class="st"> </span>mtr4 &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
x &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
mtr3[i] &lt;-<span class="st"> </span><span class="kw">mtrayl</span>(x,<span class="dt">antithetic =</span> <span class="ot">FALSE</span>)
mtr4[i] &lt;-<span class="st"> </span><span class="kw">mtrayl</span>(x)
}

<span class="co">#output the variances under two methods and get the reduction variance</span>
<span class="kw">print</span>(<span class="kw">var</span>(mtr3))
<span class="kw">print</span>(<span class="kw">var</span>(mtr4))
<span class="kw">print</span>((<span class="kw">var</span>(mtr3) <span class="op">-</span><span class="st"> </span><span class="kw">var</span>(mtr4))<span class="op">/</span><span class="kw">var</span>(mtr3))</code></pre></div>
<p>From the result above,the antithetic variable approach achieved approximately 88.6% reduction in variance at x = 1</p>
<p>5.13</p>
<p>The pdf of <span class="math inline">\(f_1\)</span> is: <span class="math display">\[f_1=xe^{-x^2/2}\]</span> The pdf of <span class="math inline">\(f_2\)</span> is: <span class="math display">\[f_2=e^{-x}\]</span> The two functions above are the importance functions I choose.They are supported on (1,∞) and are ‘close’ to <span class="math inline">\(g(x)=\frac{x^2}{\sqrt{2\pi}}e^{-x^2/2}\)</span>.We want to know which produces the smaller variance in estimating <span class="math inline">\(g(x)\)</span> by importance sampling.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="dv">10000</span>
se &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">2</span>)
g &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
<span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span>(<span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)) <span class="op">*</span><span class="st"> </span>(x <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>) 
}

<span class="co">#Using the random Weibull distribution(rweibull) to generate the required function</span>
x &lt;-<span class="st"> </span><span class="kw">rweibull</span>(m, <span class="dv">2</span>,<span class="kw">sqrt</span>(<span class="dv">2</span>)) 
fg1 &lt;-<span class="st"> </span><span class="kw">g</span>(x) <span class="op">/</span>(x<span class="op">*</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>))

<span class="co">#get the standard error</span>
se[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">sd</span>(fg1)

<span class="co">#Using the rexp to generate the required function</span>
x &lt;-<span class="st"> </span><span class="kw">rexp</span>(m, <span class="dv">1</span>) 
fg2 &lt;-<span class="st"> </span><span class="kw">g</span>(x) <span class="op">/</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>x)

<span class="co">#get the standard error</span>
se[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">sd</span>(fg2)
se</code></pre></div>
<p>From the result above,We can get the conclusion:<span class="math inline">\(f_1\)</span> produces the smaller variance than <span class="math inline">\(f_2\)</span>.</p>
<p>5.14</p>
<p>We can use the code and the function <span class="math inline">\(f_1\)</span> in the 5.13 to Obtain a Monte Carlo estimate of <span class="math inline">\(\int_0^∞ \frac{x^2}{\sqrt{2\pi}}e^{-x^2/2}{dx}\)</span> by importance sampling.The code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="dv">10000</span>
g &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
<span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>)<span class="op">*</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span>(<span class="kw">sqrt</span>(<span class="dv">2</span><span class="op">*</span>pi)) <span class="op">*</span><span class="st"> </span>(x <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>) 
}

<span class="co">#Using the random Weibull distribution(rweibull) to generate the required functions</span>
x &lt;-<span class="st"> </span><span class="kw">rweibull</span>(m, <span class="dv">2</span>,<span class="kw">sqrt</span>(<span class="dv">2</span>)) 

<span class="co">#Using the method of importance sampling</span>
fg1 &lt;-<span class="st"> </span><span class="kw">g</span>(x) <span class="op">/</span>(x<span class="op">*</span><span class="st"> </span><span class="kw">exp</span>(<span class="op">-</span>x<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="dv">2</span>))
theta1 &lt;-<span class="st"> </span><span class="kw">mean</span>(fg1)
theta1</code></pre></div>
<p>So,the Monte Carlo estimate of <span class="math inline">\(\int_0^∞ \frac{x^2}{\sqrt{2\pi}}e^{-x^2/2}\)</span>by importance sampling is 0.4004031</p>
</div>
<div id="question-2" class="section level2">
<h2>Question</h2>
<ul>
<li><p>6.9 Let <span class="math inline">\(X\)</span> be a non-negative random variable with <span class="math inline">\(\mu = E[X] &lt; ∞\)</span>. For a random sample <span class="math inline">\(x_1\)</span> ,…,<span class="math inline">\(x_n\)</span> from the distribution of X, the Gini ratio is defined by <span class="math display">\[{G}=\frac{1}{2n^2\mu}\sum_{j=1}^n \sum_{i=1}^n |x_i-x_j|\]</span> The Gini ratio is applied in economics to measure inequality in income dis- tribution (see e.g. [163]). Note that G can be written in terms of the order statistics <span class="math inline">\(x_(i)\)</span> as <span class="math display">\[{G}=\frac{1}{n^2\mu}\sum_{i=1}^n (2i-n-1)x_{(i)}\]</span> If the mean is unknown, let <span class="math inline">\(\hat{G}\)</span> be the statistic <span class="math inline">\(G\)</span> with <span class="math inline">\(\mu\)</span> replaced by <span class="math inline">\(\bar{x}\)</span>. Estimate by simulation the mean, median and deciles of <span class="math inline">\(\hat{G}\)</span> if <span class="math inline">\(X\)</span> is standard lognormal.Repeat the procedure for the uniform distribution and Bernoulli(0.1). Also construct density histograms of the replicates in each case.</p></li>
<li><p>6.10 Construct an approximate 95% confidence interval for the Gini ratio <span class="math inline">\(y = E[G]\)</span> if <span class="math inline">\(X\)</span> is lognormal with unknown parameters. Assess the coverage rate of the estimation procedure with a Monte Carlo experiment.</p></li>
<li><p>6.B Tests for association based on Pearson product moment correlation <span class="math inline">\(\rho\)</span>, Spear-man’s rank correlation coefficient <span class="math inline">\(\rho_s\)</span> , or Kendall’s coefficient <span class="math inline">\(\tau\)</span>, are implemented in cor.test. Show (empirically) that the nonparametric tests based on <span class="math inline">\(\rho_s\)</span> or <span class="math inline">\(\tau\)</span> are less powerful than the correlation test when the sampled distribution is bivariate normal. Find an example of an alternative (a bivariate distribution <span class="math inline">\((X,Y)\)</span> such that <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are dependent) such that at least one of the nonparametric tests have better empirical power than the correlation test against this alternative.</p></li>
</ul>
</div>
<div id="answer-2" class="section level2">
<h2>Answer</h2>
<p>6.9 First, we generate n order statistics of lognormal distribution, and then find the mean value of these order statistics and get Gini ratio by formula<span class="math display">\[{G}=\frac{1}{n^2\mu}\sum_{i=1}^n (2i-n-1)x_(i)\]</span></p>
<p>Repeat m times, and get a series of Gini ratios. Finally, we find the mean value ,the median and deciles.And construct density histograms of the replicates. Repeat the procedure for the uniform distribution and Bernoulli(0.1).And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="dv">1000</span>
n &lt;-<span class="st"> </span><span class="dv">20</span>
g &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
medians  &lt;-<span class="st"> </span>means &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="dv">3</span>)
y &lt;-<span class="st"> </span>gini1 &lt;-<span class="st"> </span>gini2 &lt;-<span class="st"> </span>gini3 &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)

<span class="co">#A series of gini ratios genarating from a lognormal distribution</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
  x &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">rlnorm</span>(n))
  xmean &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
  y[j] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>j<span class="op">-</span>n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x[j]
}
  gini1[i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>n<span class="op">^</span><span class="dv">2</span><span class="op">/</span>xmean<span class="op">*</span><span class="kw">sum</span>(y[<span class="dv">1</span><span class="op">:</span>n])
}

<span class="co">#A series of gini ratios genarating from a uniform distribution</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
  x &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">runif</span>(n))
  xmean &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
  y[j] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>j<span class="op">-</span>n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x[j]
}
  gini2[i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>n<span class="op">^</span><span class="dv">2</span><span class="op">/</span>xmean<span class="op">*</span><span class="kw">sum</span>(y[<span class="dv">1</span><span class="op">:</span>n])
}

<span class="co">#A series of gini ratios genarating from Bernoulli(0.1)</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
  x &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">rbinom</span>(n,<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),<span class="kw">c</span>(<span class="fl">0.1</span>,<span class="fl">0.9</span>)))
  xmean &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
  y[j] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>j<span class="op">-</span>n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x[j]
}
  gini3[i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>n<span class="op">^</span><span class="dv">2</span><span class="op">/</span>xmean<span class="op">*</span><span class="kw">sum</span>(y[<span class="dv">1</span><span class="op">:</span>n])
}

<span class="co">#construct density histograms of the replicates from the three distributions above</span>
<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">1</span>))
<span class="kw">par</span>(<span class="dt">pin=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">1</span>))
<span class="kw">hist</span>(gini1,<span class="dt">prob =</span> <span class="ot">TRUE</span>)
<span class="kw">lines</span>(<span class="kw">density</span>(gini1),<span class="dt">col =</span> <span class="st">&quot;red&quot;</span>,<span class="dt">lwd =</span> <span class="dv">2</span>)
<span class="kw">hist</span>(gini2,<span class="dt">prob =</span> <span class="ot">TRUE</span>)
<span class="kw">lines</span>(<span class="kw">density</span>(gini2),<span class="dt">col =</span> <span class="st">&quot;blue&quot;</span>,<span class="dt">lwd =</span> <span class="dv">2</span>)
<span class="kw">hist</span>(gini3,<span class="dt">prob =</span> <span class="ot">TRUE</span>)
<span class="kw">lines</span>(<span class="kw">density</span>(gini3),<span class="dt">col =</span> <span class="st">&quot;green&quot;</span>,<span class="dt">lwd =</span> <span class="dv">2</span>)

<span class="co">#get the mean values from the three distributions above</span>
medians[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">median</span>(gini1)
medians[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">median</span>(gini2)
medians[<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">median</span>(gini3)
medians

<span class="co">#get the deciles from the three distributions above</span>
quantiles1 &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">quantile</span>(gini1,<span class="kw">seq</span>(<span class="fl">0.1</span>,<span class="fl">0.9</span>,<span class="fl">0.1</span>)))
quantiles1

quantiles2 &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">quantile</span>(gini2,<span class="kw">seq</span>(<span class="fl">0.1</span>,<span class="fl">0.9</span>,<span class="fl">0.1</span>)))
quantiles2

quantiles3 &lt;-<span class="st"> </span><span class="kw">as.vector</span>(<span class="kw">quantile</span>(gini3,<span class="kw">seq</span>(<span class="fl">0.1</span>,<span class="fl">0.9</span>,<span class="fl">0.1</span>)))
quantiles3

<span class="co">#get the medians from the three distributions above</span>
means[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(gini1)
means[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(gini2)
means[<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">mean</span>(gini3)
means</code></pre></div>
<p>6.10 First,we use the method in the question 6.9 to get a series of Gini ratio which <span class="math inline">\(X\)</span> is lognormal.Then,calculate the mean and the variance and construct the approximate 95% confidence interval by the formula <span class="math inline">\((\bar{G}-\hat{\sigma t_{n-1}(\alpha/2)},\bar{G}+\hat{\sigma t_{n-1}(\alpha/2)})\)</span> and estimate the converage rate.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="dv">1000</span>
n &lt;-<span class="st"> </span><span class="dv">20</span>
gini &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)

<span class="co">#Get A series of gini ratios genarating from a lognormal distribution</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
  x &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">rlnorm</span>(n))
  xmean &lt;-<span class="st"> </span><span class="kw">mean</span>(x)
  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
  y[j] &lt;-<span class="st"> </span>(<span class="dv">2</span><span class="op">*</span>j<span class="op">-</span>n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>x[j]
}
  gini[i] &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>n<span class="op">^</span><span class="dv">2</span><span class="op">/</span>xmean<span class="op">*</span><span class="kw">sum</span>(y[<span class="dv">1</span><span class="op">:</span>n])
}

<span class="co">#get the lower confidence interval </span>
LCI&lt;-<span class="st"> </span><span class="kw">mean</span>(gini)<span class="op">-</span><span class="kw">sd</span>(gini)<span class="op">*</span><span class="kw">qt</span>(<span class="fl">0.975</span>,m<span class="op">-</span><span class="dv">1</span>)
<span class="co">#get the upper confidence interval </span>
UCI &lt;-<span class="st"> </span><span class="kw">mean</span>(gini)<span class="op">+</span><span class="kw">sd</span>(gini)<span class="op">*</span><span class="kw">qt</span>(<span class="fl">0.975</span>,m<span class="op">-</span><span class="dv">1</span>)
<span class="co">#get the confidence interval</span>
CI &lt;-<span class="st"> </span><span class="kw">c</span>(LCI,UCI)
<span class="kw">print</span>(CI)
<span class="co">#calculate the converage rte </span>
covrate&lt;-<span class="kw">sum</span>(<span class="kw">I</span>(gini<span class="op">&gt;</span>CI[<span class="dv">1</span>]<span class="op">&amp;</span>gini<span class="op">&lt;</span>CI[<span class="dv">2</span>]))<span class="op">/</span>m
<span class="kw">print</span>(covrate)</code></pre></div>
<p>Hence,the confidence interval is [0.3246208,0.6399607] and the coverage rate is 0.954.</p>
<p>6.B we chose <span class="math display">\[(X,Y)^{'}\sim N(O,\Sigma),with \Sigma=
   \left[
   \begin{matrix}
   25 &amp; 5 \\
   5 &amp; 25 
   \end{matrix}\right]
    \]</span> Here.<span class="math inline">\((X,Y)\)</span> is a bivariate normal random variable.We can calculate the correlation coefficient is 0.2.Then Show that the nonparametric tests based on <span class="math inline">\(\rho_s\)</span> and <span class="math inline">\(\tau\)</span> are less powerful than the correlation test.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#We need load the MASS package</span>
<span class="kw">library</span>(MASS)
mean &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>)                                           
sigma &lt;-<span class="st"> </span><span class="kw">matrix</span>( <span class="kw">c</span>(<span class="dv">25</span>,<span class="dv">5</span>,                            
                    <span class="dv">5</span>, <span class="dv">25</span>),<span class="dt">nrow=</span><span class="dv">2</span>, <span class="dt">ncol=</span><span class="dv">2</span>)
m &lt;-<span class="st"> </span><span class="dv">1000</span>

<span class="co">#Calculate the power using pearson correlation test by setting the parameter method as pearson</span>
pearvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    mydata1 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="dv">50</span>, mean, sigma)
    x &lt;-<span class="st"> </span>mydata1[,<span class="dv">1</span>]
    y &lt;-<span class="st"> </span>mydata1[,<span class="dv">2</span>]
    peartest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(x,y,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;pearson&quot;</span>)
    peartest<span class="op">$</span>p.value
} )
power1 &lt;-<span class="st"> </span><span class="kw">mean</span>(pearvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power1

<span class="co">#Calculate the power using spearman correlation test by setting the parameter method as spearman</span>
spearvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    mydata2 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="dv">50</span>, mean, sigma)
    x &lt;-<span class="st"> </span>mydata2[,<span class="dv">1</span>]
    y &lt;-<span class="st"> </span>mydata2[,<span class="dv">2</span>]
    speartest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(x,y,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;spearman&quot;</span>)
    speartest<span class="op">$</span>p.value
} )
power2 &lt;-<span class="st"> </span><span class="kw">mean</span>(spearvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power2

<span class="co">#Calculate the power using kendall correlation test by setting the parameter method as kendall</span>
kenvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    mydata3 &lt;-<span class="st"> </span><span class="kw">mvrnorm</span>(<span class="dv">50</span>, mean, sigma)
    x &lt;-<span class="st"> </span>mydata3[,<span class="dv">1</span>]
    y &lt;-<span class="st"> </span>mydata3[,<span class="dv">2</span>]
    kentest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(x,y,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;kendall&quot;</span>)
    kentest<span class="op">$</span>p.value
} )
power3 &lt;-<span class="st"> </span><span class="kw">mean</span>(kenvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power3</code></pre></div>
<p>From the result above,the power based on pearson correlation test is larger than the power based on nonparametric tests.So the nonparametric tests are less powerful than the correlation test based on pearson correlation test .</p>
<p>Here,<span class="math inline">\((U,V)\)</span> are dependent but they are not normal distribution,instead <span class="math inline">\(U\)</span> is a uniform distribution.Now we show that nonparametric tests have better empirical power than the correlation test.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">R &lt;-<span class="st"> </span><span class="dv">1000</span>
m &lt;-<span class="st"> </span><span class="dv">1000</span>

<span class="co">#Calculate the power using pearson correlation test by setting the parameter method as pearson</span>
pearvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    u &lt;-<span class="st"> </span><span class="kw">runif</span>(R<span class="op">/</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">10</span>)
    v &lt;-<span class="st"> </span><span class="kw">sin</span>(u)
    peartest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(u,v,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;pearson&quot;</span>)
    peartest<span class="op">$</span>p.value
} )
power1 &lt;-<span class="st"> </span><span class="kw">mean</span>(pearvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power1

<span class="co">#Calculate the power using spearman correlation test by setting the parameter method as spearman</span>
spearvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    u &lt;-<span class="st"> </span><span class="kw">runif</span>(R<span class="op">/</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">10</span>)
    v &lt;-<span class="st"> </span><span class="kw">sin</span>(u)
    speartest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(u,v,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;spearman&quot;</span>)
    speartest<span class="op">$</span>p.value
} )
power2 &lt;-<span class="st"> </span><span class="kw">mean</span>(spearvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power2

<span class="co">#Calculate the power using kendall correlation test by setting the parameter method as kendall</span>
kenvalues &lt;-<span class="st"> </span><span class="kw">replicate</span>(m, <span class="dt">expr =</span> {
    u &lt;-<span class="st"> </span><span class="kw">runif</span>(R<span class="op">/</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">10</span>)
    v &lt;-<span class="st"> </span><span class="kw">sin</span>(u)
    kentest &lt;-<span class="st"> </span><span class="kw">cor.test</span>(u,v,<span class="dt">alternative =</span> <span class="st">&quot;two.sided&quot;</span>, <span class="dt">method =</span> <span class="st">&quot;kendall&quot;</span>)
    kentest<span class="op">$</span>p.value
} )
power3 &lt;-<span class="st"> </span><span class="kw">mean</span>(kenvalues <span class="op">&lt;=</span><span class="st"> </span><span class="fl">0.05</span>)
power3</code></pre></div>
<p>So,we can draw the conclusion that there exists an example such that at least one of the nonparametric tests have better empirical power than the correlation test.</p>
</div>
<div id="question-3" class="section level2">
<h2>Question</h2>
<ul>
<li><p>7.1 Compute a jackknife estimate of the bias and the standard error of the corre- lation statistic in Example 7.2.</p></li>
<li><p>7.5 Refer to Exercise 7.4. Compute 95% bootstrap confidence intervals for the mean time between failures <span class="math inline">\(1/λ\)</span> by the standard normal, basic, percentile, and BCa methods. Compare the intervals and explain why they may differ.</p></li>
<li><p>7.8 Refer to Exercise 7.7. Obtain the jackknife estimates of bias and standard error of <span class="math inline">\(\hat{\theta}\)</span></p></li>
<li><p>7.11 In Example 7.18, leave-one-out (n-fold) cross validation was used to select the best fitting model. Use leave-two-out cross validation to compare the models.</p></li>
</ul>
</div>
<div id="answer-3" class="section level2">
<h2>Answer</h2>
<p>7.1</p>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">LAST &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">576</span>,<span class="dv">635</span>,<span class="dv">558</span>,<span class="dv">578</span> ,<span class="dv">666</span> ,<span class="dv">580</span> ,<span class="dv">555</span> ,<span class="dv">661</span> ,<span class="dv">651</span> ,<span class="dv">605</span> ,<span class="dv">653</span> ,<span class="dv">575</span> ,<span class="dv">545</span> ,<span class="dv">572</span> ,<span class="dv">594</span>)
GPA &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">339</span> ,<span class="dv">330</span> ,<span class="dv">281</span> ,<span class="dv">303</span> ,<span class="dv">344</span> ,<span class="dv">307</span> ,<span class="dv">300</span> ,<span class="dv">343</span> ,<span class="dv">336</span> ,<span class="dv">313</span> ,<span class="dv">312</span> ,<span class="dv">274</span> ,<span class="dv">276</span> ,<span class="dv">288</span> ,<span class="dv">296</span>)
n &lt;-<span class="st"> </span><span class="kw">length</span>(LAST)
theta.hat &lt;-<span class="st"> </span><span class="kw">cor</span>(LAST,GPA)  <span class="co">#the Correlation between the LAST and GPA we give above</span>
theta.jack &lt;-<span class="st"> </span><span class="kw">numeric</span>(n)</code></pre></div>
<p>In the Jackknife,the jack-knife estimate of bias is <span class="math inline">\(\hat{bias}_{jack}=(n-1)(\bar{\hat{\theta}}_{(.)}-\bar{\theta})\)</span> where <span class="math inline">\(\bar{\hat{\theta}}_{(.)}\)</span> is the mean of the estimates from the leave-one-out samples, and <span class="math inline">\(\bar{\theta}\)</span> is the estimate computed from the original observed sample.In this question,theta.hat in the above is the estimate computed from the original observed sample so we need to calculate the estimates from the leave-one-out samples..And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(bootstrap)
<span class="co">#compute the jackknife replicates, leave-one-out estimates</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n)
  theta.jack[i] &lt;-<span class="st"> </span><span class="kw">cor</span>(LAST[<span class="op">-</span>i],GPA[<span class="op">-</span>i])
bias &lt;-<span class="st"> </span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span>(<span class="kw">mean</span>(theta.jack) <span class="op">-</span><span class="st"> </span>theta.hat)
<span class="co">#jackknife estimate of bias</span>
<span class="kw">print</span>(bias) 
se &lt;-<span class="st"> </span><span class="kw">sqrt</span>((n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="st"> </span><span class="kw">mean</span>((theta.jack <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(theta.jack))<span class="op">^</span><span class="dv">2</span>))
<span class="kw">print</span>(se)</code></pre></div>
<p>So,the bias and the standard error of the correlation statistic in Example 7.2 using the Jackknife is -0.006473623 and 0.1425186.</p>
<p>7.5</p>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
air &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">18</span>,<span class="dv">43</span>,<span class="dv">85</span>,<span class="dv">91</span>,<span class="dv">98</span>,<span class="dv">100</span>,<span class="dv">130</span>,<span class="dv">230</span>,<span class="dv">487</span>)</code></pre></div>
<p>In the question,we assume the times between failures follow an exponential model <span class="math inline">\(Exp(λ)\)</span>.So the maximum likelihood function of the hazard rate <span class="math inline">\(λ\)</span> is <span class="math inline">\(λ^ne^{-λ\sum{x_i}}\)</span>.So the log-likelihood function is <span class="math inline">\(nln(λ)-λ\sum{x_i}\)</span>.The derivative of this function is <span class="math inline">\(n/λ-\sum{x_i}\)</span>.And now our goal is to get the maximum about <span class="math inline">\(λ\)</span>.Finally compute 95% bootstrap confidence intervals by the standard normal, basic, percentile,and BCa methods. The And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(boot)
lamda.boot &lt;-<span class="st"> </span><span class="cf">function</span>(data,ind) {
  f &lt;-<span class="st"> </span><span class="cf">function</span> (lamda)   n<span class="op">/</span>lamda<span class="op">-</span>s
  n &lt;-<span class="st"> </span><span class="kw">length</span>(data[ind])
  s &lt;-<span class="st"> </span><span class="kw">sum</span>(data[ind])
  
  <span class="co">#the function uniroot can be used to get the root</span>
  root &lt;-<span class="st"> </span><span class="kw">uniroot</span>(f,<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>))<span class="op">$</span>root
  <span class="dv">1</span><span class="op">/</span>root
}
boot.obj &lt;-<span class="st"> </span><span class="kw">boot</span>(<span class="dt">data=</span>air, <span class="dt">statistic =</span> lamda.boot, <span class="dt">R =</span> <span class="dv">3000</span>)
<span class="kw">print</span>(boot.obj)
<span class="kw">print</span>(<span class="kw">boot.ci</span>(boot.obj,<span class="dt">type =</span> <span class="kw">c</span>(<span class="st">&quot;basic&quot;</span>, <span class="st">&quot;norm&quot;</span>, <span class="st">&quot;perc&quot;</span>,<span class="st">&quot;bca&quot;</span>)))</code></pre></div>
<p>From the result,we get the estimation of <span class="math inline">\(1/λ\)</span> is 108.1134. The 95% bootstrap confidence intervals by the standard normal, basic, percentile,and BCa methods is (34.7,181.5),(25.4,170.7),(45.5,190.9),(56.5,222.8).Apparently,they are different because their algorithms are differnet.</p>
<p>7.8</p>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(bootstrap)
n &lt;-<span class="st"> </span><span class="kw">nrow</span>(scor)

<span class="co">#get the eigenvalues</span>
eigenvalues &lt;-<span class="st"> </span><span class="kw">eigen</span>(<span class="kw">cov</span>(scor))<span class="op">$</span>values

<span class="co">#the estimate computed from the original observed sample</span>
theta.hat &lt;-<span class="st"> </span><span class="kw">max</span>(eigenvalues)<span class="op">/</span><span class="kw">sum</span>(eigenvalues) 

theta.jack &lt;-<span class="st"> </span><span class="kw">numeric</span>(n)</code></pre></div>
<p>To sum up,7.8 is the same as the 7.1. The covariance matrix can be calculated by the cov function and the eigenvalues can be calculated by the eigen function.This function returns the eigenvalues and the eigenvectors. And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#compute the jackknife replicates, leave-one-out estimates</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n)
  theta.jack[i] &lt;-<span class="st"> </span><span class="kw">max</span>(<span class="kw">eigen</span>(<span class="kw">cov</span>(scor[<span class="op">-</span>i,]))<span class="op">$</span>values)<span class="op">/</span><span class="kw">sum</span>(<span class="kw">eigen</span>(<span class="kw">cov</span>(scor[<span class="op">-</span>i,]))<span class="op">$</span>values)
bias &lt;-<span class="st"> </span>(n <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">*</span><span class="st"> </span>(<span class="kw">mean</span>(theta.jack) <span class="op">-</span><span class="st"> </span>theta.hat)
<span class="kw">print</span>(bias) <span class="co">#jackknife estimate of bias</span>
se &lt;-<span class="st"> </span><span class="kw">sqrt</span>((n<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="st"> </span><span class="kw">mean</span>((theta.jack <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(theta.jack))<span class="op">^</span><span class="dv">2</span>))
<span class="kw">print</span>(se)</code></pre></div>
<p>So,the bias and the standard error of the correlation statistic in Example 7.2 using the Jackknife is 0.001069139 and 0.04955231.</p>
<p>7.11</p>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(DAAG)
<span class="kw">attach</span>(ironslag)
<span class="co">#the length of the chemical</span>
n &lt;-<span class="st"> </span><span class="kw">length</span>(chemical) 
<span class="co">#A pairwise combination of 1 and n</span>
comb &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">combn</span>(<span class="dv">1</span><span class="op">:</span>n,<span class="dv">2</span>))
e1 &lt;-<span class="st"> </span>e2 &lt;-<span class="st"> </span>e3 &lt;-<span class="st"> </span>e4 &lt;-<span class="st"> </span>e5 &lt;-<span class="st"> </span>e6 &lt;-<span class="st"> </span>e7 &lt;-<span class="st"> </span>e8  &lt;-<span class="st"> </span><span class="kw">numeric</span>(n) </code></pre></div>
<p>According to the question,we need use leave-two-out cross validation to get the prediction error to compare with the method of leave-one-out (n-fold) cross validation.The result by leave-one-out (n-fold) cross validation is in the page 210.So we only to get the result by leave-two-out cross validation. In the data chemical,we take 2 of the n numbers to be the test set and the n-2 numbers is the training set.In the question we use the training set to get the models and get the prediction error in the test set.In addition,I went through all the possible combinations.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
  <span class="co">#comb is a matrix with two columns</span>
  k1 &lt;-<span class="st"> </span>comb[k,<span class="dv">1</span>]
  k2 &lt;-<span class="st"> </span>comb[k,<span class="dv">2</span>]
  <span class="co">#get the training set</span>
  x &lt;-<span class="st"> </span>chemical[<span class="op">-</span>k1][<span class="op">-</span>(k2<span class="op">-</span><span class="dv">1</span>)]
  y &lt;-<span class="st"> </span>magnetic[<span class="op">-</span>k1][<span class="op">-</span>(k2<span class="op">-</span><span class="dv">1</span>)]
  <span class="co">#use the training set to get the models</span>
  J1 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x)
  <span class="co">#use the test set to get the prediction error</span>
  yhat1 &lt;-<span class="st"> </span>J1<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J1<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>chemical[k1]
  yhat2 &lt;-<span class="st"> </span>J1<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J1<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>chemical[k2]
  e1[k] &lt;-<span class="st"> </span>magnetic[k1] <span class="op">-</span><span class="st"> </span>yhat1
  e2[k] &lt;-<span class="st"> </span>magnetic[k2] <span class="op">-</span><span class="st"> </span>yhat2
  <span class="co">#the following procedures are the same as the above</span>
  J2 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(x<span class="op">^</span><span class="dv">2</span>))
  yhat3 &lt;-<span class="st"> </span>J2<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J2<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>chemical[k1] <span class="op">+</span>
<span class="st">    </span>J2<span class="op">$</span>coef[<span class="dv">3</span>] <span class="op">*</span><span class="st"> </span>chemical[k1]<span class="op">^</span><span class="dv">2</span>
  yhat4 &lt;-<span class="st"> </span>J2<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J2<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>chemical[k2] <span class="op">+</span>
<span class="st">    </span>J2<span class="op">$</span>coef[<span class="dv">3</span>] <span class="op">*</span><span class="st"> </span>chemical[k2]<span class="op">^</span><span class="dv">2</span>
  e3[k] &lt;-<span class="st"> </span>magnetic[k1] <span class="op">-</span><span class="st"> </span>yhat3
  e4[k] &lt;-<span class="st"> </span>magnetic[k2] <span class="op">-</span><span class="st"> </span>yhat4
  
  J3 &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(y) <span class="op">~</span><span class="st"> </span>x)
  logyhat5 &lt;-<span class="st"> </span>J3<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J3<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>chemical[k1]
  logyhat6 &lt;-<span class="st"> </span>J3<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J3<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>chemical[k2]
  yhat5 &lt;-<span class="st"> </span><span class="kw">exp</span>(logyhat5)
  yhat6 &lt;-<span class="st"> </span><span class="kw">exp</span>(logyhat6)
  e5[k] &lt;-<span class="st"> </span>magnetic[k1] <span class="op">-</span><span class="st"> </span>yhat5
  e6[k] &lt;-<span class="st"> </span>magnetic[k2] <span class="op">-</span><span class="st"> </span>yhat6
  
  J4 &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(y) <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(x))
  logyhat7 &lt;-<span class="st"> </span>J4<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J4<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span><span class="kw">log</span>(chemical[k1])
  logyhat8 &lt;-<span class="st"> </span>J4<span class="op">$</span>coef[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>J4<span class="op">$</span>coef[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span><span class="kw">log</span>(chemical[k2])
  yhat7 &lt;-<span class="st"> </span><span class="kw">exp</span>(logyhat7)
  yhat8 &lt;-<span class="st"> </span><span class="kw">exp</span>(logyhat8)
  e7[k] &lt;-<span class="st"> </span>magnetic[k1] <span class="op">-</span><span class="st"> </span>yhat7
  e8[k] &lt;-<span class="st"> </span>magnetic[k2] <span class="op">-</span><span class="st"> </span>yhat8
  
}

<span class="co"># get the prediction error by leave-two-out cross validation.</span>
<span class="kw">c</span>(<span class="kw">mean</span>(e1<span class="op">^</span><span class="dv">2</span><span class="op">+</span>e2<span class="op">^</span><span class="dv">2</span>), <span class="kw">mean</span>(e3<span class="op">^</span><span class="dv">2</span><span class="op">+</span>e4<span class="op">^</span><span class="dv">2</span>), <span class="kw">mean</span>(e5<span class="op">^</span><span class="dv">2</span><span class="op">+</span>e6<span class="op">^</span><span class="dv">2</span>), <span class="kw">mean</span>(e7<span class="op">^</span><span class="dv">2</span><span class="op">+</span>e8<span class="op">^</span><span class="dv">2</span>))</code></pre></div>
<p>the prediction error by the leave-one-out cross validation is 19.55644, 17.85248 ,18.44188, 20.45424.And the prediction error by the leave-two-out cross validation is 23.76840, 25.85720 ,26.47113, 27.73885.So the leave-one-out cross validation is better than the leave-two-out cross validation .</p>
</div>
<div id="question-4" class="section level2">
<h2>Question</h2>
<ul>
<li><p>8.1 Implement the two-sample Cram′ er-von Mises test for equal distributions as a permutation test. Apply the test to the data in Examples 8.1 and 8.2.</p></li>
<li><p>8.2 Design experiments for evaluating the performance of the NN,energy, and ball methods in various situations： 1. Unequal variances and equal expectations 2.Unequal variances and unequal expectations 3.Non-normal distributions: t distribution with 1 df (heavy-tailed distribution), bimodel distribution (mixture of two normal distributions) 4.Unbalanced samples (say, 1 case versus 10 controls)</p></li>
<li><p>9.3 Use the Metropolis-Hastings sampler to generate random variables from a standard Cauchy distribution. Discard the first 1000 of the chain, and compare the deciles of the generated observations with the deciles of the standard Cauchy distribution (see qcauchyor qt with df=1). Recall that a Cauchy(θ,η) distribution has density function</p></li>
</ul>
<p><span class="math display">\[{f(x)}=\frac{1}{\theta\pi(1+[(x-\eta)/\theta]^2)},-\infty&lt;x&lt;\infty,\theta&gt;0\]</span></p>
<p>The standard Cauchy has the Cauchy(θ = 1,η = 0) density. (Note that the standard Cauchy density is equal to the Student t density with one degree of freedom.)</p>
<ul>
<li>9.6 Rao [220, Sec. 5g] presented an example on genetic linkage of 197 animals in four categories (also discussed in [67, 106, 171, 266]). The group sizes are (125,18,20,34). Assume that the probabilities of the corresponding multinomial distribution are</li>
</ul>
<p><span class="math display">\[\left(\frac{1}{2}+\frac{\theta}{4},\frac{1-\theta}{4},\frac{1-\theta}{4},\frac{\theta}{4}\right)\]</span></p>
<p>Estimate the posterior distribution of <span class="math inline">\(θ\)</span> given the observed sample, using one of the methods in this chapter.</p>
</div>
<div id="answer-4" class="section level2">
<h2>Answer</h2>
<p>8.1</p>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">158</span>, <span class="dv">171</span> ,<span class="dv">193</span> ,<span class="dv">199</span> ,<span class="dv">230</span> ,<span class="dv">243</span> ,<span class="dv">248</span> ,<span class="dv">248</span> ,<span class="dv">250</span> ,<span class="dv">267</span> ,<span class="dv">271</span> ,<span class="dv">316</span> ,<span class="dv">327</span> ,<span class="dv">329</span>)
y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">141</span> ,<span class="dv">148</span> ,<span class="dv">169</span> ,<span class="dv">181</span> ,<span class="dv">203</span> ,<span class="dv">213</span> ,<span class="dv">229</span> ,<span class="dv">244</span> ,<span class="dv">257</span> ,<span class="dv">260</span> ,<span class="dv">271</span> ,<span class="dv">309</span>)
<span class="co">#the function cvm.test is used to calculate the Cramer-von Mises statistic</span>
cvm.test &lt;-<span class="st"> </span><span class="cf">function</span>(x,y){
  <span class="co">#the empirical distribution function of the x,y</span>
  F &lt;-<span class="st"> </span><span class="kw">ecdf</span>(x)
  G &lt;-<span class="st"> </span><span class="kw">ecdf</span>(y)
  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)
  m &lt;-<span class="st"> </span><span class="kw">length</span>(y)
  s &lt;-<span class="st"> </span><span class="kw">numeric</span>(n)
  t &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
  <span class="cf">for</span> (i  <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n) {
    s[i] &lt;-<span class="st"> </span>(<span class="kw">F</span>(x[i])<span class="op">-</span><span class="kw">G</span>(x[i]))<span class="op">^</span><span class="dv">2</span>
  }
  s &lt;-<span class="st"> </span><span class="kw">sum</span>(s)
  <span class="cf">for</span> (j  <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m) {
    t[j] &lt;-<span class="st"> </span>(<span class="kw">F</span>(y[j])<span class="op">-</span><span class="kw">G</span>(y[j]))<span class="op">^</span><span class="dv">2</span>
  }
  t &lt;-<span class="st"> </span><span class="kw">sum</span>(t)
  <span class="co">#return the Cramer-von Mises statistic</span>
  <span class="kw">return</span> (m<span class="op">*</span>n<span class="op">*</span>(s<span class="op">+</span>t)<span class="op">/</span>(m<span class="op">+</span>n)<span class="op">^</span><span class="dv">2</span>)
}
<span class="co">#number of replicates</span>
R &lt;-<span class="st"> </span><span class="dv">999</span> 
<span class="co">#pooled sample</span>
z &lt;-<span class="st"> </span><span class="kw">c</span>(x, y)
K &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">26</span>
<span class="co">#storage for replicates</span>
reps &lt;-<span class="st"> </span><span class="kw">numeric</span>(R) </code></pre></div>
<p>From the book,we know that the Cramer-von Mises statistic is definded as <span class="math display">\[\frac{m+n}{(m+n)^2}\left[\sum_{i=1}^n(F_n(x_i)-G_m(x_i))^2+\sum_{j=1}^m(F_n(y_j)-G_m(y_j))^2\right]\]</span>. The role of the above function is used to seek the statistic .And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">t0 &lt;-<span class="st"> </span><span class="kw">cvm.test</span>(x, y)
t0
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>R) {
  <span class="co">#generate indices k for the first sample</span>
  k &lt;-<span class="st"> </span><span class="kw">sample</span>(K, <span class="dt">size =</span> <span class="dv">14</span>, <span class="dt">replace =</span> <span class="ot">FALSE</span>)
  x1 &lt;-<span class="st"> </span>z[k]
  y1 &lt;-<span class="st"> </span>z[<span class="op">-</span>k] <span class="co">#complement of x1</span>
  reps[i] &lt;-<span class="st"> </span><span class="kw">cvm.test</span>(x1, y1)
}
p &lt;-<span class="st"> </span><span class="kw">mean</span>(<span class="kw">c</span>(t0, reps) <span class="op">&gt;=</span><span class="st"> </span>t0)
p
<span class="kw">hist</span>(reps, <span class="dt">main =</span> <span class="st">&quot;&quot;</span>, <span class="dt">freq =</span> <span class="ot">FALSE</span>, <span class="dt">xlab =</span> <span class="st">&quot;T (p = 0.421)&quot;</span>,
<span class="dt">breaks =</span> <span class="st">&quot;scott&quot;</span>)
<span class="kw">points</span>(t0, <span class="dv">0</span>, <span class="dt">cex =</span> <span class="dv">1</span>, <span class="dt">pch =</span> <span class="dv">16</span>) </code></pre></div>
<p>As we can see,the result used by the Cramer-von Mises statistic is 0.1515216.The approximate ASL 0.421 does not support the alternative hypothesis that distributions differ.The result is the same as the conclusion used by the Kolmogorov-Smirnov (K-S) statistic.</p>
<p>8.2</p>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(RANN)
<span class="kw">library</span>(boot)
<span class="kw">library</span>(energy)
<span class="kw">library</span>(Ball)
m &lt;-<span class="st"> </span><span class="dv">100</span>; k&lt;-<span class="dv">3</span>; p&lt;-<span class="dv">2</span>; mu &lt;-<span class="st"> </span><span class="fl">0.2</span>; <span class="kw">set.seed</span>(<span class="dv">12345</span>)
n1 &lt;-<span class="st"> </span>n2 &lt;-<span class="st"> </span><span class="dv">20</span>; R&lt;-<span class="dv">50</span>; n &lt;-<span class="st"> </span>n1<span class="op">+</span>n2; N =<span class="st"> </span><span class="kw">c</span>(n1,n2)
Tn &lt;-<span class="st"> </span><span class="cf">function</span>(z, ix, sizes,k) {
  n1 &lt;-<span class="st"> </span>sizes[<span class="dv">1</span>]; n2 &lt;-<span class="st"> </span>sizes[<span class="dv">2</span>]; n &lt;-<span class="st"> </span>n1 <span class="op">+</span><span class="st"> </span>n2
  <span class="cf">if</span>(<span class="kw">is.vector</span>(z)) z &lt;-<span class="st"> </span><span class="kw">data.frame</span>(z,<span class="dv">0</span>);
  z &lt;-<span class="st"> </span>z[ix, ];
  NN &lt;-<span class="st"> </span><span class="kw">nn2</span>(<span class="dt">data=</span>z, <span class="dt">k=</span>k<span class="op">+</span><span class="dv">1</span>) 
  block1 &lt;-<span class="st"> </span>NN<span class="op">$</span>nn.idx[<span class="dv">1</span><span class="op">:</span>n1,<span class="op">-</span><span class="dv">1</span>]
  block2 &lt;-<span class="st"> </span>NN<span class="op">$</span>nn.idx[(n1<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>n,<span class="op">-</span><span class="dv">1</span>]
  i1 &lt;-<span class="st"> </span><span class="kw">sum</span>(block1 <span class="op">&lt;</span><span class="st"> </span>n1 <span class="op">+</span><span class="st"> </span>.<span class="dv">5</span>); i2 &lt;-<span class="st"> </span><span class="kw">sum</span>(block2 <span class="op">&gt;</span><span class="st"> </span>n1<span class="op">+</span>.<span class="dv">5</span>)
  (i1 <span class="op">+</span><span class="st"> </span>i2) <span class="op">/</span><span class="st"> </span>(k <span class="op">*</span><span class="st"> </span>n)
}
<span class="co">#the nn method and return the p.values</span>
eqdist.nn &lt;-<span class="st"> </span><span class="cf">function</span>(z,sizes,k){
  boot.obj &lt;-<span class="st"> </span><span class="kw">boot</span>(<span class="dt">data=</span>z,<span class="dt">statistic=</span>Tn,<span class="dt">R=</span>R,
                   <span class="dt">sim =</span> <span class="st">&quot;permutation&quot;</span>, <span class="dt">sizes =</span> sizes,<span class="dt">k=</span>k)
  ts &lt;-<span class="st"> </span><span class="kw">c</span>(boot.obj<span class="op">$</span>t0,boot.obj<span class="op">$</span>t)
  p.value &lt;-<span class="st"> </span><span class="kw">mean</span>(ts<span class="op">&gt;=</span>ts[<span class="dv">1</span>])
  <span class="kw">list</span>(<span class="dt">statistic=</span>ts[<span class="dv">1</span>],<span class="dt">p.value=</span>p.value)
}

p.values1 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>,m,<span class="dv">3</span>)
p.values2 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>,m,<span class="dv">3</span>)
p.values3 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>,m,<span class="dv">3</span>)
p.values4 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="ot">NA</span>,m,<span class="dv">3</span>)</code></pre></div>
<p>In this question,we should design experiments for evaluating the performance of the NN, energy, and ball methods in various situations.Each situation is simaliar. And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#under the situation of unequal variances and equal expectations</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  <span class="co">#the sample x is from the standard normal distribution and the sample y is from the normal diisreibution with mean=0,variance is 2</span>
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span>p),<span class="dt">ncol=</span>p);
  y &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2,<span class="dt">sd=</span><span class="dv">2</span>),<span class="kw">rnorm</span>(n2,<span class="dt">sd=</span><span class="dv">2</span>));
  z &lt;-<span class="st"> </span><span class="kw">rbind</span>(x,y)
  p.values1[i,<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.nn</span>(z,N,k)<span class="op">$</span>p.value
  p.values1[i,<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.etest</span>(z,<span class="dt">sizes=</span>N,<span class="dt">R=</span>R)<span class="op">$</span>p.value
  p.values1[i,<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y,<span class="dt">R=</span><span class="dv">999</span>,<span class="dt">seed=</span>i<span class="op">*</span><span class="dv">12345</span>)<span class="op">$</span>p.value
}
alpha &lt;-<span class="st"> </span><span class="fl">0.1</span>;
pow1 &lt;-<span class="st"> </span><span class="kw">colMeans</span>(p.values1<span class="op">&lt;</span>alpha)
<span class="kw">names</span>(pow1) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">'NN'</span>,<span class="st">'energy'</span>, <span class="st">'ball '</span>)
<span class="co">#get the powers by the three method</span>
pow1

<span class="co">#under the situation of unequal variances and unequal expectations</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
    <span class="co">#the sample x is from the standard normal distribution and the sample y is from the normal diisreibution with mean=0.2 ,variance is 2</span>
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span>p),<span class="dt">ncol=</span>p);
  y &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2,<span class="dt">mean =</span> mu,<span class="dt">sd=</span><span class="dv">2</span>),<span class="kw">rnorm</span>(n2,<span class="dt">mean=</span>mu,<span class="dt">sd=</span><span class="dv">2</span>));
  z &lt;-<span class="st"> </span><span class="kw">rbind</span>(x,y)
  p.values2[i,<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.nn</span>(z,N,k)<span class="op">$</span>p.value
  p.values2[i,<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.etest</span>(z,<span class="dt">sizes=</span>N,<span class="dt">R=</span>R)<span class="op">$</span>p.value
  p.values2[i,<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y,<span class="dt">R=</span><span class="dv">999</span>,<span class="dt">seed=</span>i<span class="op">*</span><span class="dv">12345</span>)<span class="op">$</span>p.value
}
alpha &lt;-<span class="st"> </span><span class="fl">0.1</span>;
pow2 &lt;-<span class="st"> </span><span class="kw">colMeans</span>(p.values2<span class="op">&lt;</span>alpha)
<span class="kw">names</span>(pow2) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">'NN'</span>,<span class="st">'energy'</span>, <span class="st">'ball '</span>)
<span class="co">#get the powers by the three method</span>
pow2

<span class="co">#under the situation of non-normal distributions</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
      <span class="co">#the sample x is from t distribution with df=1 and the sample y is from the mixture of two normal distributions</span>
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rt</span>(n1<span class="op">*</span>p,<span class="dt">df=</span><span class="dv">1</span>),<span class="dt">ncol =</span> p);
  y &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2),<span class="kw">rnorm</span>(n2,<span class="dt">mean=</span>mu,<span class="dt">sd=</span><span class="dv">4</span>));
  z &lt;-<span class="st"> </span><span class="kw">rbind</span>(x,y)
  p.values3[i,<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.nn</span>(z,N,k)<span class="op">$</span>p.value
  p.values3[i,<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.etest</span>(z,<span class="dt">sizes=</span>N,<span class="dt">R=</span>R)<span class="op">$</span>p.value
  p.values3[i,<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y,<span class="dt">R=</span><span class="dv">999</span>,<span class="dt">seed=</span>i<span class="op">*</span><span class="dv">12345</span>)<span class="op">$</span>p.value
}
alpha &lt;-<span class="st"> </span><span class="fl">0.1</span>;
pow3 &lt;-<span class="st"> </span><span class="kw">colMeans</span>(p.values3<span class="op">&lt;</span>alpha)
<span class="kw">names</span>(pow3) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">'NN'</span>,<span class="st">'energy'</span>, <span class="st">'ball '</span>)
<span class="co">#get the powers by the three method</span>
pow3

<span class="co">#under the situation of Unbalanced samples which the number of x is 200 and y is 20</span>
n1 &lt;-<span class="st"> </span><span class="dv">200</span>
n2 &lt;-<span class="st"> </span><span class="dv">20</span>
n &lt;-<span class="st"> </span>n1<span class="op">+</span>n2
N =<span class="st"> </span><span class="kw">c</span>(n1,n2)
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>m){
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">rnorm</span>(n1<span class="op">*</span>p),<span class="dt">ncol=</span>p);
  y &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="kw">rnorm</span>(n2),<span class="kw">rnorm</span>(n2));  
  z &lt;-<span class="st"> </span><span class="kw">rbind</span>(x,y)
  p.values4[i,<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.nn</span>(z,N,k)<span class="op">$</span>p.value
  p.values4[i,<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="kw">eqdist.etest</span>(z,<span class="dt">sizes=</span>N,<span class="dt">R=</span>R)<span class="op">$</span>p.value
  p.values4[i,<span class="dv">3</span>] &lt;-<span class="st"> </span><span class="kw">bd.test</span>(<span class="dt">x=</span>x,<span class="dt">y=</span>y,<span class="dt">R=</span><span class="dv">99</span>,<span class="dt">seed=</span>i<span class="op">*</span><span class="dv">12345</span>)<span class="op">$</span>p.value
}
alpha &lt;-<span class="st"> </span><span class="fl">0.18</span>;
pow4 &lt;-<span class="st"> </span><span class="kw">colMeans</span>(p.values4<span class="op">&lt;</span>alpha)
<span class="kw">names</span>(pow4) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">'NN'</span>,<span class="st">'energy'</span>, <span class="st">'ball '</span>)
<span class="co">#get the powers by the three method</span>
pow4</code></pre></div>
<p>In conclusion,under the situations of unequal variances and equal expectations , unequal variances and unequal expectations ,the Ball method is the best and the NN method is the wrost.Under the situation of non-normal distributions,the NN is the best and the rest is very close .Under the situation of Unbalanced samples which the number of x is 200 and y is 20,the NN method is the best.Hence,in different situation,the performance of the three method is different and we need choose the best one.</p>
<p>9.3</p>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="co">#build a standard Cauchy distribution</span>
f &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">x0=</span><span class="dv">0</span>, <span class="dt">gamma=</span><span class="dv">1</span>){
  out&lt;-<span class="dv">1</span><span class="op">/</span>(pi<span class="op">*</span>gamma<span class="op">*</span>(<span class="dv">1</span><span class="op">+</span>((x<span class="op">-</span>x0)<span class="op">/</span>gamma)<span class="op">^</span><span class="dv">2</span>))
  <span class="kw">return</span>(out)
  
}
<span class="co">#the times of simulation</span>
m &lt;-<span class="st"> </span><span class="dv">80000</span>
x &lt;-<span class="st"> </span><span class="kw">numeric</span>(m)
<span class="co">#generat the normal proposal distribution with mean=xt ,sd=1</span>
x[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,<span class="dt">mean=</span><span class="dv">0</span>,<span class="dt">sd=</span><span class="dv">1</span> )
k &lt;-<span class="st"> </span><span class="dv">0</span>
u &lt;-<span class="st"> </span><span class="kw">runif</span>(m)</code></pre></div>
<p>When we use the Metropolis-Hastings sampler to generate the Markov chain,we should choose a proposal distribution which has the same support set as the target distribution.That is,in this question,the cauchy distribution is supported from <span class="math inline">\(-\infty\)</span> to <span class="math inline">\(\infty\)</span> so the proposal distribution should also be supported in the same set.Hence,I choose the normal distribution.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>m) {
  xt &lt;-<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>]
  y &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dt">mean =</span> xt,<span class="dt">sd=</span><span class="dv">1</span>)
  num &lt;-<span class="st"> </span><span class="kw">f</span>(y) <span class="op">*</span><span class="st"> </span><span class="kw">dnorm</span>(xt, <span class="dt">mean =</span> y,<span class="dt">sd=</span><span class="dv">1</span>)
  den &lt;-<span class="st"> </span><span class="kw">f</span>(xt) <span class="op">*</span><span class="st"> </span><span class="kw">dnorm</span>(y, <span class="dt">mean =</span> xt,<span class="dt">sd=</span><span class="dv">1</span>)
  <span class="cf">if</span> (u[i] <span class="op">&lt;=</span><span class="st"> </span>num<span class="op">/</span>den) x[i] &lt;-<span class="st"> </span>y <span class="cf">else</span> {
    x[i] &lt;-<span class="st"> </span>xt
    k &lt;-<span class="st"> </span>k<span class="op">+</span><span class="dv">1</span> <span class="co">#y is rejected</span>
  }
}
<span class="co">#discard the burnin sample</span>
b &lt;-<span class="st"> </span><span class="dv">1001</span> 
y &lt;-<span class="st"> </span>x[b<span class="op">:</span>m]
a &lt;-<span class="st"> </span><span class="kw">ppoints</span>(<span class="dv">200</span>)
<span class="co">#quantiles of cauchy distribution</span>
Qcauchy &lt;-<span class="st"> </span><span class="kw">qcauchy</span>(a)
<span class="co">#quantiles of sample distribution</span>
Q &lt;-<span class="st"> </span><span class="kw">quantile</span>(x, a)
<span class="kw">qqplot</span>(Qcauchy, Q,<span class="dt">xlim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>),<span class="dt">ylim=</span><span class="kw">c</span>(<span class="op">-</span><span class="dv">2</span>,<span class="dv">2</span>),<span class="dt">xlab=</span><span class="st">&quot;Cauchy Quantiles&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;Sample Quantiles&quot;</span>,<span class="dt">main =</span> <span class="kw">expression</span>(<span class="st">&quot;Q-Q plot for Cauchy distribution&quot;</span>))
<span class="kw">hist</span>(y, <span class="dt">breaks=</span><span class="dv">50</span>, <span class="dt">main=</span><span class="st">&quot;&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;&quot;</span>, <span class="dt">freq=</span><span class="ot">FALSE</span>)
<span class="kw">lines</span>(Qcauchy, <span class="kw">f</span>(Qcauchy))</code></pre></div>
<p>From the Q-Q plot and the histogram above,we can see the deciles of the generated observations and the deciles of the standard Cauchy distribution are almost the same.So, the Metropolis-Hastings chain converges to a unique stationary distribution which in this question is the standard cauchy distribution.</p>
<p>9.6</p>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">size &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">125</span>,<span class="dv">18</span>,<span class="dv">20</span>,<span class="dv">34</span>)
<span class="co">#The following function prob computes the target density</span>
prob &lt;-<span class="st"> </span><span class="cf">function</span>(y, size) {
  <span class="cf">if</span> (y <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">||</span><span class="st"> </span>y <span class="op">&gt;</span><span class="dv">1</span>)
    <span class="kw">return</span> (<span class="dv">0</span>)
  <span class="kw">return</span>((<span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">+</span>y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>size[<span class="dv">1</span>] <span class="op">*</span>
<span class="st">           </span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>size[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>size[<span class="dv">3</span>] <span class="op">*</span>(y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>size[<span class="dv">4</span>])
}
<span class="co">#length of the chain</span>
m &lt;-<span class="st"> </span><span class="dv">5000</span>
<span class="co">#width of the uniform support set</span>
w &lt;-<span class="st"> </span>.<span class="dv">25</span> 
<span class="co">#burn-in time</span>
burn &lt;-<span class="st"> </span><span class="dv">1000</span>
<span class="co">#for accept/reject step</span>
u &lt;-<span class="st"> </span><span class="kw">runif</span>(m) 
<span class="co">#proposal distribution</span>
v &lt;-<span class="st"> </span><span class="kw">runif</span>(m, <span class="op">-</span>w, w)


## Question


  <span class="op">+</span><span class="st">   </span>For exercise <span class="fl">9.6</span>, use the Gelman<span class="op">-</span>Rubin method to monitor convergence of the chain, and run the chain until the chain has converged approximately to the target distribution
according to R <span class="op">&lt;</span><span class="st"> </span><span class="fl">1.2</span>.

  <span class="op">+</span><span class="st">   </span><span class="fl">11.4</span> Find the intersection points <span class="kw">A</span>(k) <span class="cf">in</span> (<span class="dv">0</span>,<span class="op">$</span>\sqrt{A}<span class="op">$</span>)
<span class="op">$</span><span class="er">$</span>S_{k<span class="op">-</span><span class="dv">1</span>}(a)=P\<span class="kw">left</span>(<span class="kw">t</span>(k<span class="op">-</span><span class="dv">1</span>)<span class="op">&gt;</span>\sqrt{\frac{a<span class="op">^</span><span class="dv">2</span>(k<span class="op">-</span><span class="dv">1</span>)}{k<span class="op">-</span>a<span class="op">^</span><span class="dv">2</span>}}\right)<span class="op">$</span><span class="er">$</span>
and
<span class="op">$</span><span class="er">$</span>S_{k}(a)=P\<span class="kw">left</span>(<span class="kw">t</span>(k)<span class="op">&gt;</span>\sqrt{\frac{a<span class="op">^</span><span class="dv">2</span>(k)}{k<span class="op">+</span><span class="dv">1</span><span class="op">-</span>a<span class="op">^</span><span class="dv">2</span>}}\right)<span class="op">$</span><span class="er">$</span>
<span class="cf">for</span> k =<span class="st"> </span><span class="dv">4</span> <span class="op">:</span><span class="st"> </span><span class="dv">25</span>,<span class="dv">100</span>,<span class="dv">500</span>,<span class="dv">1000</span>, where <span class="kw">t</span>(k) is a Student t random variable with k degrees of <span class="kw">freedom.</span> (These intersection points determine the critical values <span class="cf">for</span> a t<span class="op">-</span>test <span class="cf">for</span> scale<span class="op">-</span>mixture errors proposed by Sz′ ekely [<span class="dv">260</span>].)



## Answer

The variables <span class="cf">in</span> this question<span class="op">:</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
size &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">125</span>,<span class="dv">18</span>,<span class="dv">20</span>,<span class="dv">34</span>)
<span class="co">#The following function prob computes the target density</span>
prob &lt;-<span class="st"> </span><span class="cf">function</span>(y, size) {
  <span class="cf">if</span> (y <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">||</span><span class="st"> </span>y <span class="op">&gt;</span><span class="dv">1</span>)
    <span class="kw">return</span> (<span class="dv">0</span>)
  <span class="kw">return</span>((<span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">+</span>y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>size[<span class="dv">1</span>] <span class="op">*</span>
<span class="st">           </span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>size[<span class="dv">2</span>] <span class="op">*</span><span class="st"> </span>((<span class="dv">1</span><span class="op">-</span>y)<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>size[<span class="dv">3</span>] <span class="op">*</span>(y<span class="op">/</span><span class="dv">4</span>)<span class="op">^</span>size[<span class="dv">4</span>])
}

Gelman.Rubin &lt;-<span class="st"> </span><span class="cf">function</span>(psi) {
  <span class="co"># psi[i,j] is the statistic psi(X[i,1:j])</span>
  <span class="co"># for chain in i-th row of X</span>
  psi &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(psi)
  n &lt;-<span class="st"> </span><span class="kw">ncol</span>(psi)
  k &lt;-<span class="st"> </span><span class="kw">nrow</span>(psi)
  psi.means &lt;-<span class="st"> </span><span class="kw">rowMeans</span>(psi) <span class="co">#row means</span>
  B &lt;-<span class="st"> </span>n <span class="op">*</span><span class="st"> </span><span class="kw">var</span>(psi.means) <span class="co">#between variance est.</span>
  psi.w &lt;-<span class="st"> </span><span class="kw">apply</span>(psi, <span class="dv">1</span>, <span class="st">&quot;var&quot;</span>) <span class="co">#within variances</span>
  W &lt;-<span class="st"> </span><span class="kw">mean</span>(psi.w) <span class="co">#within est.</span>
  v.hat &lt;-<span class="st"> </span>W<span class="op">*</span>(n<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>n <span class="op">+</span><span class="st"> </span>(B<span class="op">/</span>n) <span class="co">#upper variance est.</span>
  r.hat &lt;-<span class="st"> </span>v.hat <span class="op">/</span><span class="st"> </span>W <span class="co">#G-R statistic</span>
  <span class="kw">return</span>(r.hat)
}

multinomial.chain &lt;-<span class="st"> </span><span class="cf">function</span>(N, X1) {
  <span class="co">#generates a Metropolis chain for multino-mial distribution</span>
  <span class="co">#with uniform(-w,w) proposal distribution</span>
  <span class="co">#and starting value X1</span>
  <span class="co">#length of the chain</span>
  <span class="co">#width of the uniform support set</span>
  w &lt;-<span class="st"> </span><span class="fl">0.15</span> 
  <span class="co">#burn-in time</span>
  burn &lt;-<span class="st"> </span><span class="dv">1000</span>
  <span class="co">#for accept/reject step</span>
  u &lt;-<span class="st"> </span><span class="kw">runif</span>(N) 
  <span class="co">#proposal distribution</span>
  v &lt;-<span class="st"> </span><span class="kw">runif</span>(N, <span class="op">-</span>w, w)
  x &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, N)
  x[<span class="dv">1</span>] &lt;-<span class="st"> </span>X1
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span>N) {
    y &lt;-<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>v[i]
    r1 &lt;-<span class="st"> </span><span class="kw">prob</span>(y, size)
    r2 &lt;-<span class="st"> </span><span class="kw">prob</span>(x[i<span class="op">-</span><span class="dv">1</span>], size)
    r &lt;-<span class="st"> </span>r1<span class="op">/</span>r2
    <span class="cf">if</span> (u[i] <span class="op">&lt;=</span><span class="st"> </span>r)
      x[i] &lt;-<span class="st"> </span>y <span class="cf">else</span>
        x[i] &lt;-<span class="st"> </span>x[i<span class="op">-</span><span class="dv">1</span>]
  }
  <span class="kw">return</span>(x)
}

k &lt;-<span class="st"> </span><span class="dv">4</span> <span class="co">#number of chains to generate</span>
n &lt;-<span class="st"> </span><span class="dv">10000</span> <span class="co">#length of chains</span>
b &lt;-<span class="st"> </span><span class="dv">2000</span> <span class="co">#burn-in length</span>
<span class="co">#choose overdispersed initial values</span>
x0 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.1</span>,<span class="fl">0.4</span>,<span class="fl">0.6</span>,<span class="fl">0.9</span>)
<span class="co">#generate the chains</span>
X &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>, <span class="dt">nrow=</span>k, <span class="dt">ncol=</span>n)</code></pre></div>
<p>In this question,we should use the Gelman-Rubin method to monitor convergence of the chain and generate four chains .The proposal distribution I choose is the uniform distribution.And change the initial values which are 0.1,0.4,0.6,0.9.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>k)
  X[i, ] &lt;-<span class="st"> </span><span class="kw">multinomial.chain</span>(n, x0[i])
<span class="co">#compute diagnostic statistics</span>
psi &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">apply</span>(X, <span class="dv">1</span>, cumsum))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(psi))
  psi[i,] &lt;-<span class="st"> </span>psi[i,] <span class="op">/</span><span class="st"> </span>(<span class="dv">1</span><span class="op">:</span><span class="kw">ncol</span>(psi))
<span class="kw">print</span>(<span class="kw">Gelman.Rubin</span>(psi))
<span class="co">#get sequences of the running means ψ for four Metropolis-Hastings chains</span>
<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>k)
  <span class="kw">plot</span>(psi[i, (b<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>n], <span class="dt">type=</span><span class="st">&quot;l&quot;</span>,
       <span class="dt">xlab=</span>i, <span class="dt">ylab=</span><span class="kw">bquote</span>(psi))
<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>)) <span class="co">#restore default</span>
rhat &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, n)
<span class="cf">for</span> (j <span class="cf">in</span> (b<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>n)
rhat[j] &lt;-<span class="st"> </span><span class="kw">Gelman.Rubin</span>(psi[,<span class="dv">1</span><span class="op">:</span>j])
<span class="kw">plot</span>(rhat[(b<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span>n], <span class="dt">type=</span><span class="st">&quot;l&quot;</span>, <span class="dt">xlab=</span><span class="st">&quot;&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;R&quot;</span>)
<span class="kw">abline</span>(<span class="dt">h=</span><span class="fl">1.05</span>, <span class="dt">lty=</span><span class="dv">2</span>)</code></pre></div>
<p>So, the <span class="math inline">\(\hat{R}\)</span> of the chain is 1.030325.</p>
</div>
<div id="section" class="section level2">
<h2>11.4</h2>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#return the function about a,k </span>
m &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">4</span><span class="op">:</span><span class="dv">25</span>,<span class="dv">100</span>,<span class="dv">500</span>,<span class="dv">1000</span>)
root &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(m))
f1 &lt;-<span class="st"> </span><span class="cf">function</span>(a,k) <span class="kw">pt</span>(<span class="kw">sqrt</span>(a<span class="op">^</span><span class="dv">2</span><span class="op">*</span>(k<span class="op">-</span><span class="dv">1</span>)<span class="op">/</span>(k<span class="op">-</span>a<span class="op">^</span><span class="dv">2</span>)),k<span class="op">-</span><span class="dv">1</span>)<span class="op">-</span><span class="kw">pt</span>(<span class="kw">sqrt</span>(a<span class="op">^</span><span class="dv">2</span><span class="op">*</span>(k)<span class="op">/</span>(k<span class="op">+</span><span class="dv">1</span><span class="op">-</span>a<span class="op">^</span><span class="dv">2</span>)),k)</code></pre></div>
<p>First,if there exists a point satisfies <span class="math inline">\(P\left(t(k-1)&gt;\sqrt{\frac{a^2(k-1)}{k-a^2}}\right)\)</span> = <span class="math inline">\(P\left(t(k)&gt;\sqrt{\frac{a^2(k)}{k+1-a^2}}\right)\)</span>,then this point also satisfies <span class="math inline">\(P\left(t(k-1)≤\sqrt{\frac{a^2(k-1)}{k-a^2}}\right)\)</span> = <span class="math inline">\(P\left(t(k)≤\sqrt{\frac{a^2(k)}{k+1-a^2}}\right)\)</span>.So,we can use pt function to calculate.Then,we create a function f1 to represent the curve.And use the uniroot to solve this problem.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#use uniroot to get the point</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">4</span><span class="op">:</span><span class="dv">25</span>) {
  res &lt;-<span class="st"> </span><span class="kw">uniroot</span>(f1,<span class="kw">c</span>(<span class="fl">1e-5</span>,<span class="dv">2</span>),<span class="dt">k=</span>i)
  root[i<span class="op">-</span><span class="dv">3</span>] &lt;-<span class="st"> </span>res<span class="op">$</span>root
}
res1 &lt;-<span class="st"> </span><span class="kw">uniroot</span>(f1,<span class="kw">c</span>(<span class="fl">1e-5</span>,<span class="dv">2</span>),<span class="dt">k=</span><span class="dv">100</span>)
root[<span class="dv">23</span>] &lt;-<span class="st"> </span>res1<span class="op">$</span>root
res2 &lt;-<span class="st"> </span><span class="kw">uniroot</span>(f1,<span class="kw">c</span>(<span class="fl">1e-5</span>,<span class="dv">2</span>),<span class="dt">k=</span><span class="dv">500</span>)
root[<span class="dv">24</span>] &lt;-<span class="st"> </span>res2<span class="op">$</span>root
res3 &lt;-<span class="st"> </span><span class="kw">uniroot</span>(f1,<span class="kw">c</span>(<span class="fl">1e-5</span>,<span class="dv">2</span>),<span class="dt">k=</span><span class="dv">1000</span>)
root[<span class="dv">25</span>] &lt;-<span class="st"> </span>res3<span class="op">$</span>root
data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">k=</span>m,<span class="dt">a=</span>root,<span class="dt">row.names=</span><span class="dv">1</span>)
data</code></pre></div>
<p>So,the intersection points for k = 4 : 25,100,500,1000 is 1.492103, 1.533556, 1.562744, 1.584430, 1.601185, 1.614521, 1.625390, 1.634419, 1.642038 ,1.648554, 1.654190, 1.659114, 1.663452, 1.667303, 1.670745, 1.673840, 1.676637, 1.679178 , 1.681496, 1.683620, 1.685572, 1.687373,1.720608, 1.729755 , 1.730907.</p>
</div>
<div id="question-5" class="section level2">
<h2>Question</h2>
<ul>
<li><p>11.6 Write a function to compute the cdf of the Cauchy distribution, which has density <span class="math display">\[{f(x)}=\frac{1}{\theta\pi(1+[(x-\eta)/\theta]^2)},-\infty&lt;x&lt;\infty\]</span> where θ &gt; 0. Compare your results to the results from the R function pcauchy.(Also see the source code in pcauchy.c.)</p>
<ul>
<li>A-B-O blood type problem
<ul>
<li><p>Let the three alleles be A, B, and O.</p>
<pre><code>  Genotype    AA   BB   OO   AO   BO   AB    AA
  Frequency   p2   q2   r2   2pr  2qr  2pq   1
  Count       nAA  nBB  nOO  nAO  nBO  nAB   n</code></pre></li>
<li><p>Observed data: <span class="math inline">\(n_{A\cdot}=n_{AA}+n_{AO}=28\)</span> (A-type), <span class="math inline">\(n_{B\cdot}=n_{BB}+n_{BO}=24\)</span> (B-type), <span class="math inline">\(n_{OO}=41\)</span> (O-type), <span class="math inline">\(n_{AB}=70\)</span> (AB-type).</p></li>
<li><p>Use EM algorithm to solve MLE of <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> (consider missing data <span class="math inline">\(n_{AA}\)</span> and <span class="math inline">\(n_{BB}\)</span>).</p></li>
<li><p>Record the maximum likelihood values in M-steps, are they increasing?</p></li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="answer-5" class="section level2">
<h2>Answer</h2>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="dt">digits=</span><span class="dv">6</span>)
<span class="co">#get the density of cauchy distribution with the parameter theta and eta</span>
f &lt;-<span class="st"> </span><span class="cf">function</span>(x, theta, eta) {
  <span class="dv">1</span><span class="op">/</span>theta<span class="op">/</span>pi<span class="op">/</span>(<span class="dv">1</span><span class="op">+</span>((x<span class="op">-</span>eta)<span class="op">/</span>theta)<span class="op">^</span><span class="dv">2</span>)
}
<span class="co">#the vector x is used to get the cdf of cauchy distribution when theta is 1,eta is 0</span>
x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="op">-</span><span class="dv">5</span>,<span class="dv">5</span>,<span class="fl">0.1</span>)
values &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(x))
<span class="co">#the vector x2 is used to get the cdf of cauchy distribution when theta is 1,eta is 10</span>
x2 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">10</span>,<span class="fl">0.1</span>)
values2 &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(x2))</code></pre></div>
<p>Use the function integrate to calculate the cdf of cauchy distribution.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#the situation when theta is 1 and eta is 0</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x))
  values[i] &lt;-<span class="st"> </span><span class="kw">integrate</span>(f, <span class="dt">lower=</span><span class="op">-</span><span class="ot">Inf</span>, <span class="dt">upper=</span>x[i],<span class="dt">rel.tol=</span>.Machine<span class="op">$</span>double.eps<span class="op">^</span><span class="fl">0.25</span>,<span class="dt">theta=</span><span class="dv">1</span>, <span class="dt">eta=</span><span class="dv">0</span>)<span class="op">$</span>value
<span class="co">#</span>
data &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">value=</span>values,<span class="dt">truevalues=</span><span class="kw">pcauchy</span>(x),<span class="dt">errors=</span>values<span class="op">-</span><span class="kw">pcauchy</span>(x))
data[<span class="dv">1</span><span class="op">:</span><span class="dv">20</span>,]
<span class="co">#compare the cauchy distributions,one of them is used integrate and the other is used pcauchy</span>
<span class="kw">plot</span>(x,values,<span class="dt">pch=</span><span class="dv">21</span>,<span class="dt">xlab=</span><span class="st">&quot;the values of x&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;the cauchy distribution function &quot;</span>,<span class="dt">main =</span> <span class="kw">expression</span>(<span class="st">&quot;the compare for Cauchy distribution when </span><span class="ch">\n</span><span class="st">theta is 1 and eta is 0 with two methods&quot;</span>))
<span class="kw">lines</span>(x,<span class="kw">pcauchy</span>(x),<span class="dt">col=</span><span class="st">'red'</span>,<span class="dt">lwd=</span><span class="dv">2</span>)


<span class="co">#the situation when theta is 1 and eta is 10</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x2))
  values2[i] &lt;-<span class="st"> </span><span class="kw">integrate</span>(f, <span class="dt">lower=</span><span class="op">-</span><span class="ot">Inf</span>,<span class="dt">upper=</span>x2[i],<span class="dt">rel.tol=</span>.Machine<span class="op">$</span>double.eps<span class="op">^</span><span class="fl">0.25</span>,<span class="dt">theta=</span><span class="dv">1</span>, <span class="dt">eta=</span><span class="dv">10</span>)<span class="op">$</span>value
data2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">value=</span>values2,<span class="dt">truevalues=</span><span class="kw">pcauchy</span>(x2,<span class="dt">location=</span><span class="dv">10</span>,<span class="dt">scale=</span><span class="dv">1</span>),<span class="dt">error=</span>values2<span class="op">-</span><span class="kw">pcauchy</span>(x2,<span class="dt">location=</span><span class="dv">10</span>,<span class="dt">scale=</span><span class="dv">1</span>))
data2[<span class="dv">1</span><span class="op">:</span><span class="dv">20</span>,]
<span class="co">#compare the cauchy distributions,one of them is used integrate and the other is used pcauchy</span>
<span class="kw">plot</span>(x2,values2,<span class="dt">pch=</span><span class="dv">21</span>,<span class="dt">xlab=</span><span class="st">&quot;the values of x&quot;</span>, <span class="dt">ylab=</span><span class="st">&quot;the cauchy distribution function &quot;</span>,<span class="dt">main =</span> <span class="kw">expression</span>(<span class="st">&quot;the compare for Cauchy distribution when </span><span class="ch">\n</span><span class="st">theta is 1 and eta is 10 with two methods&quot;</span>))
<span class="kw">lines</span>(x2,<span class="kw">pcauchy</span>(x2,<span class="dt">location =</span> <span class="dv">10</span>,<span class="dt">scale =</span> <span class="dv">1</span>),<span class="dt">col=</span><span class="st">'red'</span>,<span class="dt">lwd=</span><span class="dv">2</span>)</code></pre></div>
</div>
<div id="a-b-o-blood-type-problem" class="section level2">
<h2>A-B-O blood type problem</h2>
<p>The variables in this question:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(nloptr)
<span class="co"># the maximum likehood function</span>
f &lt;-<span class="st"> </span><span class="cf">function</span>(x,x1,<span class="dt">nA=</span><span class="dv">28</span>,<span class="dt">nB=</span><span class="dv">24</span>,<span class="dt">nOO=</span><span class="dv">41</span>,<span class="dt">nAB=</span><span class="dv">70</span>) {
  r1&lt;-<span class="dv">1</span><span class="op">-</span><span class="kw">sum</span>(x1)
  nAA&lt;-nA<span class="op">*</span>x1[<span class="dv">1</span>]<span class="op">^</span><span class="dv">2</span><span class="op">/</span>(x1[<span class="dv">1</span>]<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>x1[<span class="dv">1</span>]<span class="op">*</span>r1)
  nBB&lt;-nB<span class="op">*</span>x1[<span class="dv">2</span>]<span class="op">^</span><span class="dv">2</span><span class="op">/</span>(x1[<span class="dv">2</span>]<span class="op">^</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span><span class="op">*</span>x1[<span class="dv">2</span>]<span class="op">*</span>r1)
  r&lt;-<span class="dv">1</span><span class="op">-</span><span class="kw">sum</span>(x)
  <span class="kw">return</span>(<span class="op">-</span><span class="dv">2</span><span class="op">*</span>nAA<span class="op">*</span><span class="kw">log</span>(x[<span class="dv">1</span>])<span class="op">-</span><span class="dv">2</span><span class="op">*</span>nBB<span class="op">*</span><span class="kw">log</span>(x[<span class="dv">2</span>])<span class="op">-</span><span class="dv">2</span><span class="op">*</span>nOO<span class="op">*</span><span class="kw">log</span>(r)<span class="op">-</span>
<span class="st">           </span>(nA<span class="op">-</span>nAA)<span class="op">*</span><span class="kw">log</span>(<span class="dv">2</span><span class="op">*</span>x[<span class="dv">1</span>]<span class="op">*</span>r)<span class="op">-</span>(nB<span class="op">-</span>nBB)<span class="op">*</span><span class="kw">log</span>(<span class="dv">2</span><span class="op">*</span>x[<span class="dv">2</span>]<span class="op">*</span>r)<span class="op">-</span>nAB<span class="op">*</span><span class="kw">log</span>(<span class="dv">2</span><span class="op">*</span>x[<span class="dv">1</span>]<span class="op">*</span>x[<span class="dv">2</span>]))
}

<span class="co"># constraint function </span>
g &lt;-<span class="st"> </span><span class="cf">function</span>(x,x1,<span class="dt">nA=</span><span class="dv">28</span>,<span class="dt">nB=</span><span class="dv">24</span>,<span class="dt">nOO=</span><span class="dv">41</span>,<span class="dt">nAB=</span><span class="dv">70</span>) {
  <span class="kw">return</span>(<span class="kw">sum</span>(x)<span class="op">-</span><span class="fl">0.999999</span>)
}

opts &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;algorithm&quot;</span>=<span class="st">&quot;NLOPT_LN_COBYLA&quot;</span>,
             <span class="st">&quot;xtol_rel&quot;</span>=<span class="fl">1.0e-8</span>)
mle&lt;-<span class="ot">NULL</span>
r&lt;-<span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>)
r&lt;-<span class="kw">rbind</span>(r,<span class="kw">c</span>(<span class="fl">0.2</span>,<span class="fl">0.35</span>))<span class="co"># the beginning value of p0 and q0</span>
j&lt;-<span class="dv">2</span></code></pre></div>
<p>We can see that the complete data likelihood is <span class="math display">\[l(p,q|n_{AA},n_{BB},n_{OO},n_{A.},n_{B.},n_{AB})=2n_{AA}log(p)+2n_{BB}log(q)+2n_{OO}log(r)+(n_{A.}-n_{AA})log(2pr)+(n_{B.}-n_{BB})log(2qr)+n_{AB}log(2pq) \]</span> where <span class="math inline">\(r=1-p-q\)</span>. and we can min <span class="math inline">\(-E[l(p,q|n_{AA},n_{BB},n_{OO},n_{A.},n_{B.},n_{AB})]\)</span>. .And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">while</span> (<span class="kw">sum</span>(<span class="kw">abs</span>(r[j,]<span class="op">-</span>r[j<span class="op">-</span><span class="dv">1</span>,]))<span class="op">&gt;</span><span class="fl">1e-8</span>) {
res &lt;-<span class="st"> </span><span class="kw">nloptr</span>( <span class="dt">x0=</span><span class="kw">c</span>(<span class="fl">0.3</span>,<span class="fl">0.25</span>),
               <span class="dt">eval_f=</span>f,
               <span class="dt">lb =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>), <span class="dt">ub =</span> <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>), 
               <span class="dt">eval_g_ineq =</span> g, 
               <span class="dt">opts =</span> opts, <span class="dt">x1=</span>r[j,],<span class="dt">nA=</span><span class="dv">28</span>,<span class="dt">nB=</span><span class="dv">24</span>,<span class="dt">nOO=</span><span class="dv">41</span>,<span class="dt">nAB=</span><span class="dv">70</span> )
j&lt;-j<span class="op">+</span><span class="dv">1</span>
r&lt;-<span class="kw">rbind</span>(r,res<span class="op">$</span>solution)
mle&lt;-<span class="kw">c</span>(mle,<span class="kw">f</span>(<span class="dt">x=</span>r[j,],<span class="dt">x1=</span>r[j<span class="op">-</span><span class="dv">1</span>,]))
}
r  <span class="co">#the result of EM algorithm</span>
mle <span class="co">#the max likelihood values</span></code></pre></div>
<p>So,p is 0.327344 and q is 0.310427 and from my code,it shows that the maximum likelihood values are increasing.</p>
</div>
<div id="question-6" class="section level2">
<h2>Question</h2>
<ul>
<li>page 204
<ul>
<li><p>3.Use both for loops and lapply() to fit linear models to the mtcars using the formulas stored in this list:</p>
<pre><code>                formulas &lt;- list(
          mpg ~ disp,
          mpg ~ I(1 / disp),
          mpg ~ disp + wt,
          mpg ~ I(1 / disp) + wt
          )</code></pre></li>
<li><p>4.Fit the model mpg ~ disp to each of the bootstrap replicates of mtcars in the list below by using a for loop and lapply() .Can you do it without an anonymous function?</p>
<pre><code>      bootstraps &lt;- lapply(1:10, function(i) {
      rows &lt;- sample(1:nrow(mtcars), rep = TRUE)
      mtcars[rows, ]
      })</code></pre></li>
<li><ol start="5" style="list-style-type: decimal">
<li><p>For each model in the previous two exercises, extract R 2 using the function below.</p>
<pre><code> rsq &lt;- function(mod) summary(mod)$r.squared</code></pre></li>
</ol></li>
</ul></li>
<li><p>page 214</p>
<ul>
<li><p>3.The following code simulates the performance of a t-test for non-normal data. Use sapply() and an anonymous function to extract the p-value from every trial. trials &lt;- replicate( 100, t.test(rpois(10, 10), rpois(7, 10)), simplify = FALSE ) Extra challenge: get rid of the anonymous function by using [[ directly.</p></li>
<li><p>6.Implement a combination of Map() and vapply() to create an lapply() variant that iterates in parallel over all of its inputs and stores its outputs in a vector (or a matrix). What arguments should the function take?</p></li>
</ul></li>
</ul>
</div>
<div id="answers" class="section level2">
<h2>Answers</h2>
</div>
<div id="page204" class="section level2">
<h2>page204</h2>
<ol start="3" style="list-style-type: decimal">
<li></li>
</ol>
<p>First,we use lapply to fit linear models.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">formulas &lt;-<span class="st"> </span><span class="kw">list</span>(
  mpg <span class="op">~</span><span class="st"> </span>disp,
  mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>disp),
  mpg <span class="op">~</span><span class="st"> </span>disp <span class="op">+</span><span class="st"> </span>wt,
  mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>disp) <span class="op">+</span><span class="st"> </span>wt
)
<span class="kw">lapply</span>(formulas,lm,<span class="dt">data=</span>mtcars)</code></pre></div>
<p>In this situation,we use loop for to fit linear models.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(formulas))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(formulas)) {
out[[i]] &lt;-<span class="st"> </span><span class="kw">lm</span>(formulas[[i]], <span class="dt">data =</span> mtcars)
}
out</code></pre></div>
<p>It’s seems the two methods are the same.</p>
</div>
<div id="page204-1" class="section level2">
<h2>page204</h2>
<ol start="4" style="list-style-type: decimal">
<li></li>
</ol>
<p>It’s the same as the question 3.First,we use lapply to fit linear model..And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
bootstraps &lt;-<span class="st"> </span><span class="kw">lapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="cf">function</span>(i) {
  rows &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(mtcars), <span class="dt">rep =</span> <span class="ot">TRUE</span>)
  mtcars[rows, ]
})
getvalue &lt;-<span class="st"> </span><span class="cf">function</span>(x){
  vars &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">'mpg'</span>,<span class="st">'disp'</span>)
  x[vars]
}
data &lt;-<span class="st"> </span><span class="kw">lapply</span>(bootstraps, getvalue)
<span class="kw">lapply</span>(data,lm)</code></pre></div>
<p>In this situation,we use loop for to fit linear models.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
out1 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(bootstraps))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(bootstraps)) {
out1[[i]] &lt;-<span class="st"> </span><span class="kw">getvalue</span>(bootstraps[[i]])
}

out2 &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(out1))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(out1)) {
out2[[i]] &lt;-<span class="st"> </span><span class="kw">lm</span>(out1[[i]])
}
out2</code></pre></div>
<p>Hence,the two methods get the same answer.</p>
<ol start="5" style="list-style-type: decimal">
<li></li>
</ol>
<p>In the both previous exercises,we use lapply to get the r.squared.It’s easy.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">formulas &lt;-<span class="st"> </span><span class="kw">list</span>(
  mpg <span class="op">~</span><span class="st"> </span>disp,
  mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>disp),
  mpg <span class="op">~</span><span class="st"> </span>disp <span class="op">+</span><span class="st"> </span>wt,
  mpg <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span>disp) <span class="op">+</span><span class="st"> </span>wt
)
funclist &lt;-<span class="st"> </span><span class="kw">lapply</span>(formulas,lm,<span class="dt">data=</span>mtcars)
rsq &lt;-<span class="st"> </span><span class="cf">function</span>(mod) <span class="kw">summary</span>(mod)<span class="op">$</span>r.squared
<span class="kw">lapply</span>(funclist, rsq)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">getvalue &lt;-<span class="st"> </span><span class="cf">function</span>(x){
  vars &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">'mpg'</span>,<span class="st">'disp'</span>)
  x[vars]
}
data &lt;-<span class="st"> </span><span class="kw">lapply</span>(bootstraps, getvalue)
data1 &lt;-<span class="st"> </span><span class="kw">lapply</span>(data,lm)
rsq &lt;-<span class="st"> </span><span class="cf">function</span>(mod) <span class="kw">summary</span>(mod)<span class="op">$</span>r.squared
<span class="kw">unlist</span>(<span class="kw">lapply</span>(data1, rsq))</code></pre></div>
</div>
<div id="page214" class="section level2">
<h2>page214</h2>
<ol start="3" style="list-style-type: decimal">
<li></li>
</ol>
<p>We use sapply to get the pvalue.And in the sapply,I use an anonymous function to extract the p-value from every trial.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">trials &lt;-<span class="st"> </span><span class="kw">replicate</span>(
  <span class="dv">100</span>,
  <span class="kw">t.test</span>(<span class="kw">rpois</span>(<span class="dv">10</span>, <span class="dv">10</span>), <span class="kw">rpois</span>(<span class="dv">7</span>, <span class="dv">10</span>)),
  <span class="dt">simplify =</span> <span class="ot">FALSE</span>
)
<span class="co">#use an anonymous function</span>
<span class="kw">sapply</span>(trials, <span class="cf">function</span>(mod) mod<span class="op">$</span>p.value)</code></pre></div>
<ol start="6" style="list-style-type: decimal">
<li></li>
</ol>
<p>In this question,we should create an lapply() variant that iterates in parallel over all of its inputs.And in my next code,the lapply1 function can parallelly get the sum of the input vectors and the lapply2 function can parallelly get the product of the input vectors.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#create the a,b,c vectors and a dataframe d</span>
a &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>)
b &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>)
c &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>)
d &lt;-<span class="st"> </span><span class="kw">data.frame</span>(a,b,c)
<span class="co">#the lapply1 function can parallelly get the sum of the input vectors</span>
lapply1 &lt;-<span class="st"> </span><span class="cf">function</span>(x,...){
  args &lt;-<span class="st"> </span><span class="kw">list</span>(x,...)
  <span class="cf">for</span> (a <span class="cf">in</span> args) x &lt;-<span class="st"> </span>x<span class="op">+</span>a
  x
}
<span class="kw">lapply1</span>(a,b,c)
<span class="kw">lapply1</span>(d[<span class="dv">1</span>],d[<span class="dv">2</span>],d[<span class="dv">3</span>])
<span class="co">#the lapply2 function can parallelly get the product of the input vectors</span>
lapply2 &lt;-<span class="st"> </span><span class="cf">function</span>(x,...){
  args &lt;-<span class="st"> </span><span class="kw">list</span>(...)
  <span class="cf">for</span> (a <span class="cf">in</span> args) x &lt;-<span class="st"> </span>x<span class="op">*</span>a
  x
}
<span class="kw">lapply2</span>(a,b,c)</code></pre></div>
</div>
<div id="question-7" class="section level2">
<h2>Question</h2>
<ul>
<li>page 365
<ul>
<li><p>4.Make a faster version of chisq.test() that only computes the chi-square test statistic when the input is two numeric vectors with no missing values. You can try simplifying chisq.test() or by coding from the mathematical definition ( <a href="http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test">http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test</a> ).</p></li>
<li><ol start="5" style="list-style-type: decimal">
<li>Can you make a faster version of table() for the case of an input of two integer vectors with no missing values? Can you use it to speed up your chi-square test?</li>
</ol></li>
</ul></li>
</ul>
</div>
<div id="answers-1" class="section level2">
<h2>Answers</h2>
</div>
<div id="page365" class="section level2">
<h2>page365</h2>
<ol start="4" style="list-style-type: decimal">
<li></li>
</ol>
<p>First,we get the source code about the chisq.test as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chisq.test &lt;-<span class="st"> </span><span class="cf">function</span> (x, <span class="dt">y =</span> <span class="ot">NULL</span>, <span class="dt">correct =</span> <span class="ot">TRUE</span>, <span class="dt">p =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">length</span>(x), <span class="kw">length</span>(x)), 
          <span class="dt">rescale.p =</span> <span class="ot">FALSE</span>, <span class="dt">simulate.p.value =</span> <span class="ot">FALSE</span>, <span class="dt">B =</span> <span class="dv">2000</span>) 
{
  DNAME &lt;-<span class="st"> </span><span class="kw">deparse</span>(<span class="kw">substitute</span>(x))
  <span class="cf">if</span> (<span class="kw">is.data.frame</span>(x)) 
    x &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(x)
  <span class="cf">if</span> (<span class="kw">is.matrix</span>(x)) {
    <span class="cf">if</span> (<span class="kw">min</span>(<span class="kw">dim</span>(x)) <span class="op">==</span><span class="st"> </span>1L) 
      x &lt;-<span class="st"> </span><span class="kw">as.vector</span>(x)
  }
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.matrix</span>(x) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span><span class="kw">is.null</span>(y)) {
    <span class="cf">if</span> (<span class="kw">length</span>(x) <span class="op">!=</span><span class="st"> </span><span class="kw">length</span>(y)) 
      <span class="kw">stop</span>(<span class="st">&quot;'x' and 'y' must have the same length&quot;</span>)
    DNAME2 &lt;-<span class="st"> </span><span class="kw">deparse</span>(<span class="kw">substitute</span>(y))
    xname &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="kw">length</span>(DNAME) <span class="op">&gt;</span><span class="st"> </span>1L <span class="op">||</span><span class="st"> </span><span class="kw">nchar</span>(DNAME, <span class="st">&quot;w&quot;</span>) <span class="op">&gt;</span><span class="st"> </span>
<span class="st">                 </span><span class="dv">30</span>) 
      <span class="st">&quot;&quot;</span>
    <span class="cf">else</span> DNAME
    yname &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="kw">length</span>(DNAME2) <span class="op">&gt;</span><span class="st"> </span>1L <span class="op">||</span><span class="st"> </span><span class="kw">nchar</span>(DNAME2, <span class="st">&quot;w&quot;</span>) <span class="op">&gt;</span><span class="st"> </span>
<span class="st">                 </span><span class="dv">30</span>) 
      <span class="st">&quot;&quot;</span>
    <span class="cf">else</span> DNAME2
    OK &lt;-<span class="st"> </span><span class="kw">complete.cases</span>(x, y)
    x &lt;-<span class="st"> </span><span class="kw">factor</span>(x[OK])
    y &lt;-<span class="st"> </span><span class="kw">factor</span>(y[OK])
    <span class="cf">if</span> ((<span class="kw">nlevels</span>(x) <span class="op">&lt;</span><span class="st"> </span>2L) <span class="op">||</span><span class="st"> </span>(<span class="kw">nlevels</span>(y) <span class="op">&lt;</span><span class="st"> </span>2L)) 
      <span class="kw">stop</span>(<span class="st">&quot;'x' and 'y' must have at least 2 levels&quot;</span>)
    x &lt;-<span class="st"> </span><span class="kw">table</span>(x, y)
    <span class="kw">names</span>(<span class="kw">dimnames</span>(x)) &lt;-<span class="st"> </span><span class="kw">c</span>(xname, yname)
    DNAME &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">paste</span>(DNAME, <span class="dt">collapse =</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>), <span class="st">&quot;and&quot;</span>, 
                   <span class="kw">paste</span>(DNAME2, <span class="dt">collapse =</span> <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>))
  }
  <span class="cf">if</span> (<span class="kw">any</span>(x <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">||</span><span class="st"> </span><span class="kw">anyNA</span>(x)) 
    <span class="kw">stop</span>(<span class="st">&quot;all entries of 'x' must be nonnegative and finite&quot;</span>)
  <span class="cf">if</span> ((n &lt;-<span class="st"> </span><span class="kw">sum</span>(x)) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) 
    <span class="kw">stop</span>(<span class="st">&quot;at least one entry of 'x' must be positive&quot;</span>)
  <span class="cf">if</span> (simulate.p.value) {
    setMETH &lt;-<span class="st"> </span><span class="cf">function</span>() METHOD &lt;&lt;-<span class="st"> </span><span class="kw">paste</span>(METHOD, <span class="st">&quot;with simulated p-value</span><span class="ch">\n\t</span><span class="st"> (based on&quot;</span>, 
                                           B, <span class="st">&quot;replicates)&quot;</span>)
    almost.<span class="dv">1</span> &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span><span class="dv">64</span> <span class="op">*</span><span class="st"> </span>.Machine<span class="op">$</span>double.eps
  }
  <span class="cf">if</span> (<span class="kw">is.matrix</span>(x)) {
    METHOD &lt;-<span class="st"> &quot;Pearson's Chi-squared test&quot;</span>
    nr &lt;-<span class="st"> </span><span class="kw">as.integer</span>(<span class="kw">nrow</span>(x))
    nc &lt;-<span class="st"> </span><span class="kw">as.integer</span>(<span class="kw">ncol</span>(x))
    <span class="cf">if</span> (<span class="kw">is.na</span>(nr) <span class="op">||</span><span class="st"> </span><span class="kw">is.na</span>(nc) <span class="op">||</span><span class="st"> </span><span class="kw">is.na</span>(nr <span class="op">*</span><span class="st"> </span>nc)) 
      <span class="kw">stop</span>(<span class="st">&quot;invalid nrow(x) or ncol(x)&quot;</span>, <span class="dt">domain =</span> <span class="ot">NA</span>)
    sr &lt;-<span class="st"> </span><span class="kw">rowSums</span>(x)
    sc &lt;-<span class="st"> </span><span class="kw">colSums</span>(x)
    E &lt;-<span class="st"> </span><span class="kw">outer</span>(sr, sc, <span class="st">&quot;*&quot;</span>)<span class="op">/</span>n
    v &lt;-<span class="st"> </span><span class="cf">function</span>(r, c, n) c <span class="op">*</span><span class="st"> </span>r <span class="op">*</span><span class="st"> </span>(n <span class="op">-</span><span class="st"> </span>r) <span class="op">*</span><span class="st"> </span>(n <span class="op">-</span><span class="st"> </span>c)<span class="op">/</span>n<span class="op">^</span><span class="dv">3</span>
    V &lt;-<span class="st"> </span><span class="kw">outer</span>(sr, sc, v, n)
    <span class="kw">dimnames</span>(E) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(x)
    <span class="cf">if</span> (simulate.p.value <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">all</span>(sr <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">all</span>(sc <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)) {
      <span class="kw">setMETH</span>()
      tmp &lt;-<span class="st"> </span><span class="kw">.Call</span>(C_chisq_sim, sr, sc, B, E)
      STATISTIC &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">sort</span>((x <span class="op">-</span><span class="st"> </span>E)<span class="op">^</span><span class="dv">2</span><span class="op">/</span>E, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>))
      PARAMETER &lt;-<span class="st"> </span><span class="ot">NA</span>
      PVAL &lt;-<span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(tmp <span class="op">&gt;=</span><span class="st"> </span>almost.<span class="dv">1</span> <span class="op">*</span><span class="st"> </span>STATISTIC))<span class="op">/</span>(B <span class="op">+</span><span class="st"> </span>
<span class="st">                                                        </span><span class="dv">1</span>)
    }
    <span class="cf">else</span> {
      <span class="cf">if</span> (simulate.p.value) 
        <span class="kw">warning</span>(<span class="st">&quot;cannot compute simulated p-value with zero marginals&quot;</span>)
      <span class="cf">if</span> (correct <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">nrow</span>(x) <span class="op">==</span><span class="st"> </span>2L <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">ncol</span>(x) <span class="op">==</span><span class="st"> </span>2L) {
        YATES &lt;-<span class="st"> </span><span class="kw">min</span>(<span class="fl">0.5</span>, <span class="kw">abs</span>(x <span class="op">-</span><span class="st"> </span>E))
        <span class="cf">if</span> (YATES <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) 
          METHOD &lt;-<span class="st"> </span><span class="kw">paste</span>(METHOD, <span class="st">&quot;with Yates' continuity correction&quot;</span>)
      }
      <span class="cf">else</span> YATES &lt;-<span class="st"> </span><span class="dv">0</span>
      STATISTIC &lt;-<span class="st"> </span><span class="kw">sum</span>((<span class="kw">abs</span>(x <span class="op">-</span><span class="st"> </span>E) <span class="op">-</span><span class="st"> </span>YATES)<span class="op">^</span><span class="dv">2</span><span class="op">/</span>E)
      PARAMETER &lt;-<span class="st"> </span>(nr <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>(nc <span class="op">-</span><span class="st"> </span>1L)
      PVAL &lt;-<span class="st"> </span><span class="kw">pchisq</span>(STATISTIC, PARAMETER, <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)
    }
  }
  <span class="cf">else</span> {
    <span class="cf">if</span> (<span class="kw">length</span>(<span class="kw">dim</span>(x)) <span class="op">&gt;</span><span class="st"> </span>2L) 
      <span class="kw">stop</span>(<span class="st">&quot;invalid 'x'&quot;</span>)
    <span class="cf">if</span> (<span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span>1L) 
      <span class="kw">stop</span>(<span class="st">&quot;'x' must at least have 2 elements&quot;</span>)
    <span class="cf">if</span> (<span class="kw">length</span>(x) <span class="op">!=</span><span class="st"> </span><span class="kw">length</span>(p)) 
      <span class="kw">stop</span>(<span class="st">&quot;'x' and 'p' must have the same number of elements&quot;</span>)
    <span class="cf">if</span> (<span class="kw">any</span>(p <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span>)) 
      <span class="kw">stop</span>(<span class="st">&quot;probabilities must be non-negative.&quot;</span>)
    <span class="cf">if</span> (<span class="kw">abs</span>(<span class="kw">sum</span>(p) <span class="op">-</span><span class="st"> </span><span class="dv">1</span>) <span class="op">&gt;</span><span class="st"> </span><span class="kw">sqrt</span>(.Machine<span class="op">$</span>double.eps)) {
      <span class="cf">if</span> (rescale.p) 
        p &lt;-<span class="st"> </span>p<span class="op">/</span><span class="kw">sum</span>(p)
      <span class="cf">else</span> <span class="kw">stop</span>(<span class="st">&quot;probabilities must sum to 1.&quot;</span>)
    }
    METHOD &lt;-<span class="st"> &quot;Chi-squared test for given probabilities&quot;</span>
    E &lt;-<span class="st"> </span>n <span class="op">*</span><span class="st"> </span>p
    V &lt;-<span class="st"> </span>n <span class="op">*</span><span class="st"> </span>p <span class="op">*</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>p)
    STATISTIC &lt;-<span class="st"> </span><span class="kw">sum</span>((x <span class="op">-</span><span class="st"> </span>E)<span class="op">^</span><span class="dv">2</span><span class="op">/</span>E)
    <span class="kw">names</span>(E) &lt;-<span class="st"> </span><span class="kw">names</span>(x)
    <span class="cf">if</span> (simulate.p.value) {
      <span class="kw">setMETH</span>()
      nx &lt;-<span class="st"> </span><span class="kw">length</span>(x)
      sm &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">sample.int</span>(nx, B <span class="op">*</span><span class="st"> </span>n, <span class="ot">TRUE</span>, <span class="dt">prob =</span> p), 
                   <span class="dt">nrow =</span> n)
      ss &lt;-<span class="st"> </span><span class="kw">apply</span>(sm, 2L, <span class="cf">function</span>(x, E, k) {
        <span class="kw">sum</span>((<span class="kw">table</span>(<span class="kw">factor</span>(x, <span class="dt">levels =</span> 1L<span class="op">:</span>k)) <span class="op">-</span><span class="st"> </span>E)<span class="op">^</span><span class="dv">2</span><span class="op">/</span>E)
      }, <span class="dt">E =</span> E, <span class="dt">k =</span> nx)
      PARAMETER &lt;-<span class="st"> </span><span class="ot">NA</span>
      PVAL &lt;-<span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(ss <span class="op">&gt;=</span><span class="st"> </span>almost.<span class="dv">1</span> <span class="op">*</span><span class="st"> </span>STATISTIC))<span class="op">/</span>(B <span class="op">+</span><span class="st"> </span>
<span class="st">                                                       </span><span class="dv">1</span>)
    }
    <span class="cf">else</span> {
      PARAMETER &lt;-<span class="st"> </span><span class="kw">length</span>(x) <span class="op">-</span><span class="st"> </span><span class="dv">1</span>
      PVAL &lt;-<span class="st"> </span><span class="kw">pchisq</span>(STATISTIC, PARAMETER, <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)
    }
  }
  <span class="kw">names</span>(STATISTIC) &lt;-<span class="st"> &quot;X-squared&quot;</span>
  <span class="kw">names</span>(PARAMETER) &lt;-<span class="st"> &quot;df&quot;</span>
  <span class="cf">if</span> (<span class="kw">any</span>(E <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span>) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">is.finite</span>(PARAMETER)) 
    <span class="kw">warning</span>(<span class="st">&quot;Chi-squared approximation may be incorrect&quot;</span>)
  <span class="kw">structure</span>(<span class="kw">list</span>(<span class="dt">statistic =</span> STATISTIC, <span class="dt">parameter =</span> PARAMETER, 
                 <span class="dt">p.value =</span> PVAL, <span class="dt">method =</span> METHOD, <span class="dt">data.name =</span> DNAME, <span class="dt">observed =</span> x, 
                 <span class="dt">expected =</span> E, <span class="dt">residuals =</span> (x <span class="op">-</span><span class="st"> </span>E)<span class="op">/</span><span class="kw">sqrt</span>(E), <span class="dt">stdres =</span> (x <span class="op">-</span><span class="st"> </span>
<span class="st">                                                                        </span>E)<span class="op">/</span><span class="kw">sqrt</span>(V)), <span class="dt">class =</span> <span class="st">&quot;htest&quot;</span>)
}</code></pre></div>
<p>As you can see,the source code about chisq.test consider many different situations including how to deal with the missing values.However,in this question the vectors are complete so we can delete some unused code. And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chisq.test1&lt;-<span class="st"> </span><span class="cf">function</span> (x, <span class="dt">y =</span> <span class="ot">NULL</span>, <span class="dt">correct =</span> <span class="ot">TRUE</span>, <span class="dt">p =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">/</span><span class="kw">length</span>(x), <span class="kw">length</span>(x)), 
          <span class="dt">rescale.p =</span> <span class="ot">FALSE</span>, <span class="dt">simulate.p.value =</span> <span class="ot">FALSE</span>, <span class="dt">B =</span> <span class="dv">2000</span>) 
{
  DNAME &lt;-<span class="st"> </span><span class="kw">deparse</span>(<span class="kw">substitute</span>(x))
  <span class="co">#get the total sum of x</span>
  n &lt;-<span class="st"> </span><span class="kw">sum</span>(x)
  <span class="cf">if</span> (<span class="kw">is.matrix</span>(x)) {
    METHOD &lt;-<span class="st"> &quot;changed Pearson's Chi-squared test&quot;</span>
    nr &lt;-<span class="st"> </span><span class="kw">as.integer</span>(<span class="kw">nrow</span>(x))
    nc &lt;-<span class="st"> </span><span class="kw">as.integer</span>(<span class="kw">ncol</span>(x))
    <span class="cf">if</span> (<span class="kw">is.na</span>(nr) <span class="op">||</span><span class="st"> </span><span class="kw">is.na</span>(nc) <span class="op">||</span><span class="st"> </span><span class="kw">is.na</span>(nr <span class="op">*</span><span class="st"> </span>nc)) 
      <span class="kw">stop</span>(<span class="st">&quot;invalid nrow(x) or ncol(x)&quot;</span>, <span class="dt">domain =</span> <span class="ot">NA</span>)
    <span class="co">#get the rowsums of x</span>
    sr &lt;-<span class="st"> </span><span class="kw">rowSums</span>(x)
    <span class="co">#get the colsums of x</span>
    sc &lt;-<span class="st"> </span><span class="kw">colSums</span>(x)
    <span class="co">#The sum of rows and columns that's sr,sc divided by n</span>
    E &lt;-<span class="st"> </span><span class="kw">outer</span>(sr, sc, <span class="st">&quot;*&quot;</span>)<span class="op">/</span>n
    v &lt;-<span class="st"> </span><span class="cf">function</span>(r, c, n) c <span class="op">*</span><span class="st"> </span>r <span class="op">*</span><span class="st"> </span>(n <span class="op">-</span><span class="st"> </span>r) <span class="op">*</span><span class="st"> </span>(n <span class="op">-</span><span class="st"> </span>c)<span class="op">/</span>n<span class="op">^</span><span class="dv">3</span>
    V &lt;-<span class="st"> </span><span class="kw">outer</span>(sr, sc, v, n)
    <span class="kw">dimnames</span>(E) &lt;-<span class="st"> </span><span class="kw">dimnames</span>(x)
    <span class="co">#the situation of the sum of rows and columns are all not equal 0</span>
    <span class="cf">if</span> (simulate.p.value <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">all</span>(sr <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">all</span>(sc <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>)) {
      <span class="kw">setMETH</span>()
      tmp &lt;-<span class="st"> </span><span class="kw">.Call</span>(C_chisq_sim, sr, sc, B, E)
      STATISTIC &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">sort</span>((x <span class="op">-</span><span class="st"> </span>E)<span class="op">^</span><span class="dv">2</span><span class="op">/</span>E, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>))
      PARAMETER &lt;-<span class="st"> </span><span class="ot">NA</span>
      PVAL &lt;-<span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="kw">sum</span>(tmp <span class="op">&gt;=</span><span class="st"> </span>almost.<span class="dv">1</span> <span class="op">*</span><span class="st"> </span>STATISTIC))<span class="op">/</span>(B <span class="op">+</span><span class="st"> </span>
<span class="st">                                                        </span><span class="dv">1</span>)
    }
    <span class="cf">else</span> {
      <span class="cf">if</span> (simulate.p.value) 
        <span class="kw">warning</span>(<span class="st">&quot;cannot compute simulated p-value with zero marginals&quot;</span>)
      <span class="cf">if</span> (correct <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">nrow</span>(x) <span class="op">==</span><span class="st"> </span>2L <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">ncol</span>(x) <span class="op">==</span><span class="st"> </span>2L) {
        YATES &lt;-<span class="st"> </span><span class="kw">min</span>(<span class="fl">0.5</span>, <span class="kw">abs</span>(x <span class="op">-</span><span class="st"> </span>E))
        <span class="cf">if</span> (YATES <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) 
          METHOD &lt;-<span class="st"> </span><span class="kw">paste</span>(METHOD, <span class="st">&quot;with Yates' continuity correction&quot;</span>)
      }
      <span class="cf">else</span> YATES &lt;-<span class="st"> </span><span class="dv">0</span>
      STATISTIC &lt;-<span class="st"> </span><span class="kw">sum</span>((<span class="kw">abs</span>(x <span class="op">-</span><span class="st"> </span>E) <span class="op">-</span><span class="st"> </span>YATES)<span class="op">^</span><span class="dv">2</span><span class="op">/</span>E)
      PARAMETER &lt;-<span class="st"> </span>(nr <span class="op">-</span><span class="st"> </span>1L) <span class="op">*</span><span class="st"> </span>(nc <span class="op">-</span><span class="st"> </span>1L)
      PVAL &lt;-<span class="st"> </span><span class="kw">pchisq</span>(STATISTIC, PARAMETER, <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)
    }
  }
  <span class="kw">names</span>(STATISTIC) &lt;-<span class="st"> &quot;X-squared&quot;</span>
  <span class="kw">names</span>(PARAMETER) &lt;-<span class="st"> &quot;df&quot;</span>
  <span class="cf">if</span> (<span class="kw">any</span>(E <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span>) <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">is.finite</span>(PARAMETER)) 
    <span class="kw">warning</span>(<span class="st">&quot;Chi-squared approximation may be incorrect&quot;</span>)
  <span class="co">#output the result</span>
  <span class="kw">structure</span>(<span class="kw">list</span>(<span class="dt">statistic =</span> STATISTIC, <span class="dt">parameter =</span> PARAMETER, 
                 <span class="dt">p.value =</span> PVAL, <span class="dt">method =</span> METHOD, <span class="dt">data.name =</span> DNAME, <span class="dt">observed =</span> x, 
                 <span class="dt">expected =</span> E, <span class="dt">residuals =</span> (x <span class="op">-</span><span class="st"> </span>E)<span class="op">/</span><span class="kw">sqrt</span>(E), <span class="dt">stdres =</span> (x <span class="op">-</span><span class="st"> </span>
<span class="st">                                                                        </span>E)<span class="op">/</span><span class="kw">sqrt</span>(V)), <span class="dt">class =</span> <span class="st">&quot;htest&quot;</span>)
}</code></pre></div>
<p>Comparing the two method.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(vcd)
Treatment &lt;-<span class="st"> </span>Arthritis<span class="op">$</span>Treatment
Improved &lt;-<span class="st"> </span>Arthritis<span class="op">$</span>Improved
mytable &lt;-<span class="st"> </span><span class="kw">table</span>(Treatment,Improved)
<span class="co">#you can see the changed chisq.test1's output is the same as the original function</span>
<span class="kw">chisq.test</span>(mytable)
<span class="kw">chisq.test1</span>(mytable)

<span class="co">#compare the calculate speed</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="fl">1e5</span>,<span class="fl">1e6</span>,<span class="dv">10</span>)
y &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="fl">1e5</span>,<span class="fl">1e6</span>,<span class="dv">10</span>)
<span class="kw">system.time</span>(<span class="kw">chisq.test</span>(<span class="kw">rbind</span>(x,y)))
<span class="kw">system.time</span>(<span class="kw">chisq.test1</span>(<span class="kw">rbind</span>(x,y)))</code></pre></div>
<p>So,the chisq.test1 is faster than the original one.</p>
</div>
<div id="page204-2" class="section level2">
<h2>page204</h2>
<ol start="5" style="list-style-type: decimal">
<li></li>
</ol>
<p>It’s the same as the question 4.First,we get the source code about the table as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table &lt;-<span class="st"> </span><span class="cf">function</span> (..., <span class="dt">exclude =</span> <span class="cf">if</span> (useNA <span class="op">==</span><span class="st"> &quot;no&quot;</span>) <span class="kw">c</span>(<span class="ot">NA</span>, <span class="ot">NaN</span>), <span class="dt">useNA =</span> <span class="kw">c</span>(<span class="st">&quot;no&quot;</span>, 
    <span class="st">&quot;ifany&quot;</span>, <span class="st">&quot;always&quot;</span>), <span class="dt">dnn =</span> <span class="kw">list.names</span>(...), <span class="dt">deparse.level =</span> <span class="dv">1</span>) 
{
    list.names &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
        l &lt;-<span class="st"> </span><span class="kw">as.list</span>(<span class="kw">substitute</span>(<span class="kw">list</span>(...)))[<span class="op">-</span>1L]
        nm &lt;-<span class="st"> </span><span class="kw">names</span>(l)
        fixup &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="kw">is.null</span>(nm)) 
            <span class="kw">seq_along</span>(l)
        <span class="cf">else</span> nm <span class="op">==</span><span class="st"> &quot;&quot;</span>
        dep &lt;-<span class="st"> </span><span class="kw">vapply</span>(l[fixup], <span class="cf">function</span>(x) <span class="cf">switch</span>(deparse.level <span class="op">+</span><span class="st"> </span>
<span class="st">            </span><span class="dv">1</span>, <span class="st">&quot;&quot;</span>, <span class="cf">if</span> (<span class="kw">is.symbol</span>(x)) <span class="kw">as.character</span>(x) <span class="cf">else</span> <span class="st">&quot;&quot;</span>, 
            <span class="kw">deparse</span>(x, <span class="dt">nlines =</span> <span class="dv">1</span>)[1L]), <span class="st">&quot;&quot;</span>)
        <span class="cf">if</span> (<span class="kw">is.null</span>(nm)) 
            dep
        <span class="cf">else</span> {
            nm[fixup] &lt;-<span class="st"> </span>dep
            nm
        }
    }
    miss.use &lt;-<span class="st"> </span><span class="kw">missing</span>(useNA)
    miss.exc &lt;-<span class="st"> </span><span class="kw">missing</span>(exclude)
    useNA &lt;-<span class="st"> </span><span class="cf">if</span> (miss.use <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span>miss.exc <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span><span class="kw">match</span>(<span class="ot">NA</span>, exclude, 
        <span class="dt">nomatch =</span> 0L)) 
        <span class="st">&quot;ifany&quot;</span>
    <span class="cf">else</span> <span class="kw">match.arg</span>(useNA)
    doNA &lt;-<span class="st"> </span>useNA <span class="op">!=</span><span class="st"> &quot;no&quot;</span>
    <span class="cf">if</span> (<span class="op">!</span>miss.use <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span>miss.exc <span class="op">&amp;&amp;</span><span class="st"> </span>doNA <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">match</span>(<span class="ot">NA</span>, exclude, 
        <span class="dt">nomatch =</span> 0L)) 
        <span class="kw">warning</span>(<span class="st">&quot;'exclude' containing NA and 'useNA' != </span><span class="ch">\&quot;</span><span class="st">no</span><span class="ch">\&quot;</span><span class="st">' are a bit contradicting&quot;</span>)
    args &lt;-<span class="st"> </span><span class="kw">list</span>(...)
    <span class="cf">if</span> (<span class="op">!</span><span class="kw">length</span>(args)) 
        <span class="kw">stop</span>(<span class="st">&quot;nothing to tabulate&quot;</span>)
    <span class="cf">if</span> (<span class="kw">length</span>(args) <span class="op">==</span><span class="st"> </span>1L <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">is.list</span>(args[[1L]])) {
        args &lt;-<span class="st"> </span>args[[1L]]
        <span class="cf">if</span> (<span class="kw">length</span>(dnn) <span class="op">!=</span><span class="st"> </span><span class="kw">length</span>(args)) 
            dnn &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(argn &lt;-<span class="st"> </span><span class="kw">names</span>(args))) 
                argn
            <span class="cf">else</span> <span class="kw">paste</span>(dnn[1L], <span class="kw">seq_along</span>(args), <span class="dt">sep =</span> <span class="st">&quot;.&quot;</span>)
    }
    bin &lt;-<span class="st"> </span>0L
    lens &lt;-<span class="st"> </span><span class="ot">NULL</span>
    dims &lt;-<span class="st"> </span><span class="kw">integer</span>()
    pd &lt;-<span class="st"> </span>1L
    dn &lt;-<span class="st"> </span><span class="ot">NULL</span>
    <span class="cf">for</span> (a <span class="cf">in</span> args) {
        <span class="cf">if</span> (<span class="kw">is.null</span>(lens)) 
            lens &lt;-<span class="st"> </span><span class="kw">length</span>(a)
        <span class="cf">else</span> <span class="cf">if</span> (<span class="kw">length</span>(a) <span class="op">!=</span><span class="st"> </span>lens) 
            <span class="kw">stop</span>(<span class="st">&quot;all arguments must have the same length&quot;</span>)
        fact.a &lt;-<span class="st"> </span><span class="kw">is.factor</span>(a)
        <span class="cf">if</span> (doNA) 
            aNA &lt;-<span class="st"> </span><span class="kw">anyNA</span>(a)
        <span class="cf">if</span> (<span class="op">!</span>fact.a) {
            a0 &lt;-<span class="st"> </span>a
            a &lt;-<span class="st"> </span><span class="kw">factor</span>(a, <span class="dt">exclude =</span> exclude)
        }
        add.na &lt;-<span class="st"> </span>doNA
        <span class="cf">if</span> (add.na) {
            ifany &lt;-<span class="st"> </span>(useNA <span class="op">==</span><span class="st"> &quot;ifany&quot;</span>)
            anNAc &lt;-<span class="st"> </span><span class="kw">anyNA</span>(a)
            add.na &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="op">!</span>ifany <span class="op">||</span><span class="st"> </span>anNAc) {
                ll &lt;-<span class="st"> </span><span class="kw">levels</span>(a)
                <span class="cf">if</span> (add.ll &lt;-<span class="st"> </span><span class="op">!</span><span class="kw">anyNA</span>(ll)) {
                  ll &lt;-<span class="st"> </span><span class="kw">c</span>(ll, <span class="ot">NA</span>)
                  <span class="ot">TRUE</span>
                }
                <span class="cf">else</span> <span class="cf">if</span> (<span class="op">!</span>ifany <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span>anNAc) 
                  <span class="ot">FALSE</span>
                <span class="cf">else</span> <span class="ot">TRUE</span>
            }
            <span class="cf">else</span> <span class="ot">FALSE</span>
        }
        <span class="cf">if</span> (add.na) 
            a &lt;-<span class="st"> </span><span class="kw">factor</span>(a, <span class="dt">levels =</span> ll, <span class="dt">exclude =</span> <span class="ot">NULL</span>)
        <span class="cf">else</span> ll &lt;-<span class="st"> </span><span class="kw">levels</span>(a)
        a &lt;-<span class="st"> </span><span class="kw">as.integer</span>(a)
        <span class="cf">if</span> (fact.a <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span>miss.exc) {
            ll &lt;-<span class="st"> </span>ll[keep &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">match</span>(ll, exclude, <span class="dt">nomatch =</span> 0L) <span class="op">==</span><span class="st"> </span>
<span class="st">                </span>0L)]
            a &lt;-<span class="st"> </span><span class="kw">match</span>(a, keep)
        }
        <span class="cf">else</span> <span class="cf">if</span> (<span class="op">!</span>fact.a <span class="op">&amp;&amp;</span><span class="st"> </span>add.na) {
            <span class="cf">if</span> (ifany <span class="op">&amp;&amp;</span><span class="st"> </span><span class="op">!</span>aNA <span class="op">&amp;&amp;</span><span class="st"> </span>add.ll) {
                ll &lt;-<span class="st"> </span>ll[<span class="op">!</span><span class="kw">is.na</span>(ll)]
                <span class="kw">is.na</span>(a) &lt;-<span class="st"> </span><span class="kw">match</span>(a0, <span class="kw">c</span>(exclude, <span class="ot">NA</span>), <span class="dt">nomatch =</span> 0L) <span class="op">&gt;</span><span class="st"> </span>
<span class="st">                  </span>0L
            }
            <span class="cf">else</span> {
                <span class="kw">is.na</span>(a) &lt;-<span class="st"> </span><span class="kw">match</span>(a0, exclude, <span class="dt">nomatch =</span> 0L) <span class="op">&gt;</span><span class="st"> </span>
<span class="st">                  </span>0L
            }
        }
        nl &lt;-<span class="st"> </span><span class="kw">length</span>(ll)
        dims &lt;-<span class="st"> </span><span class="kw">c</span>(dims, nl)
        <span class="cf">if</span> (<span class="kw">prod</span>(dims) <span class="op">&gt;</span><span class="st"> </span>.Machine<span class="op">$</span>integer.max) 
            <span class="kw">stop</span>(<span class="st">&quot;attempt to make a table with &gt;= 2^31 elements&quot;</span>)
        dn &lt;-<span class="st"> </span><span class="kw">c</span>(dn, <span class="kw">list</span>(ll))
        bin &lt;-<span class="st"> </span>bin <span class="op">+</span><span class="st"> </span>pd <span class="op">*</span><span class="st"> </span>(a <span class="op">-</span><span class="st"> </span>1L)
        pd &lt;-<span class="st"> </span>pd <span class="op">*</span><span class="st"> </span>nl
    }
    <span class="kw">names</span>(dn) &lt;-<span class="st"> </span>dnn
    bin &lt;-<span class="st"> </span>bin[<span class="op">!</span><span class="kw">is.na</span>(bin)]
    <span class="cf">if</span> (<span class="kw">length</span>(bin)) 
        bin &lt;-<span class="st"> </span>bin <span class="op">+</span><span class="st"> </span>1L
    y &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">tabulate</span>(bin, pd), dims, <span class="dt">dimnames =</span> dn)
    <span class="kw">class</span>(y) &lt;-<span class="st"> &quot;table&quot;</span>
    y
}</code></pre></div>
<p>The original table function also consider different situation hence we delete some unused code because the vectors are integer. And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">table2 &lt;-<span class="st"> </span><span class="cf">function</span> (... , <span class="dt">dnn =</span> <span class="kw">list.names</span>(...), <span class="dt">deparse.level =</span> <span class="dv">1</span>) 
{
  list.names &lt;-<span class="st"> </span><span class="cf">function</span>(...) {
    l &lt;-<span class="st"> </span><span class="kw">as.list</span>(<span class="kw">substitute</span>(<span class="kw">list</span>(...)))[<span class="op">-</span>1L]
    nm &lt;-<span class="st"> </span><span class="kw">names</span>(l)
    fixup &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="kw">is.null</span>(nm)) 
      <span class="kw">seq_along</span>(l)
    <span class="cf">else</span> nm <span class="op">==</span><span class="st"> &quot;&quot;</span>
    dep &lt;-<span class="st"> </span><span class="kw">vapply</span>(l[fixup], <span class="cf">function</span>(x) <span class="cf">switch</span>(deparse.level <span class="op">+</span><span class="st"> </span>
<span class="st">                                                 </span><span class="dv">1</span>, <span class="st">&quot;&quot;</span>, <span class="cf">if</span> (<span class="kw">is.symbol</span>(x)) <span class="kw">as.character</span>(x) <span class="cf">else</span> <span class="st">&quot;&quot;</span>, 
                                               <span class="kw">deparse</span>(x, <span class="dt">nlines =</span> <span class="dv">1</span>)[1L]), <span class="st">&quot;&quot;</span>)
    <span class="cf">if</span> (<span class="kw">is.null</span>(nm)) 
      dep
    <span class="cf">else</span> {
      nm[fixup] &lt;-<span class="st"> </span>dep
      nm
    }
  }

  args &lt;-<span class="st"> </span><span class="kw">list</span>(...)
  <span class="cf">if</span> (<span class="kw">length</span>(args) <span class="op">==</span><span class="st"> </span>1L <span class="op">&amp;&amp;</span><span class="st"> </span><span class="kw">is.list</span>(args[[1L]])) {
    args &lt;-<span class="st"> </span>args[[1L]]
    <span class="cf">if</span> (<span class="kw">length</span>(dnn) <span class="op">!=</span><span class="st"> </span><span class="kw">length</span>(args)) 
      dnn &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="op">!</span><span class="kw">is.null</span>(argn &lt;-<span class="st"> </span><span class="kw">names</span>(args))) 
        argn
    <span class="cf">else</span> <span class="kw">paste</span>(dnn[1L], <span class="kw">seq_along</span>(args), <span class="dt">sep =</span> <span class="st">&quot;.&quot;</span>)
  }
  bin &lt;-<span class="st"> </span>0L
  lens &lt;-<span class="st"> </span><span class="ot">NULL</span>
  dims &lt;-<span class="st"> </span><span class="kw">integer</span>()
  pd &lt;-<span class="st"> </span>1L
  dn &lt;-<span class="st"> </span><span class="ot">NULL</span>
  <span class="cf">for</span> (a <span class="cf">in</span> args) {
    <span class="cf">if</span> (<span class="kw">is.null</span>(lens)) 
      lens &lt;-<span class="st"> </span><span class="kw">length</span>(a)
    <span class="cf">else</span> <span class="cf">if</span> (<span class="kw">length</span>(a) <span class="op">!=</span><span class="st"> </span>lens) 
      <span class="kw">stop</span>(<span class="st">&quot;all arguments must have the same length&quot;</span>)
    fact.a &lt;-<span class="st"> </span><span class="kw">is.factor</span>(a)
    <span class="cf">if</span> (<span class="op">!</span>fact.a) {
      a0 &lt;-<span class="st"> </span>a
      a &lt;-<span class="st"> </span><span class="kw">factor</span>(a)
    }
    ll &lt;-<span class="st"> </span><span class="kw">levels</span>(a)
    a &lt;-<span class="st"> </span><span class="kw">as.integer</span>(a)
    nl &lt;-<span class="st"> </span><span class="kw">length</span>(ll)
    dims &lt;-<span class="st"> </span><span class="kw">c</span>(dims, nl)
    <span class="cf">if</span> (<span class="kw">prod</span>(dims) <span class="op">&gt;</span><span class="st"> </span>.Machine<span class="op">$</span>integer.max) 
      <span class="kw">stop</span>(<span class="st">&quot;attempt to make a table with &gt;= 2^31 elements&quot;</span>)
    dn &lt;-<span class="st"> </span><span class="kw">c</span>(dn, <span class="kw">list</span>(ll))
    bin &lt;-<span class="st"> </span>bin <span class="op">+</span><span class="st"> </span>pd <span class="op">*</span><span class="st"> </span>(a <span class="op">-</span><span class="st"> </span>1L)
    pd &lt;-<span class="st"> </span>pd <span class="op">*</span><span class="st"> </span>nl
  }
  <span class="kw">names</span>(dn) &lt;-<span class="st"> </span>dnn
  bin &lt;-<span class="st"> </span>bin[<span class="op">!</span><span class="kw">is.na</span>(bin)]
  <span class="cf">if</span> (<span class="kw">length</span>(bin)) 
    bin &lt;-<span class="st"> </span>bin <span class="op">+</span><span class="st"> </span>1L
  y &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">tabulate</span>(bin, pd), dims, <span class="dt">dimnames =</span> dn)
  <span class="kw">class</span>(y) &lt;-<span class="st"> &quot;table&quot;</span>
  y
}</code></pre></div>
<p>And we compare the spending time by the two function.And the code is as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
z &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">50</span>,<span class="fl">1e7</span>,<span class="dt">replace =</span> <span class="ot">TRUE</span>)
<span class="kw">system.time</span>(<span class="kw">table</span>(z))
<span class="kw">system.time</span>(<span class="kw">table2</span>(z))</code></pre></div>
<p>Hence,the changed method get more fast.And we can use the changed function table2 to speed up the chi-square test.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
